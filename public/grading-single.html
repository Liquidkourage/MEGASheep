<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEGASheep - Single User Grading Interface</title>
    <link rel="stylesheet" href="styles.css?v=2025-08-14T15-18-12">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #000033 100%);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 5px;
            min-height: 100vh;
            overflow-x: hidden;
            width: 100%;
            box-sizing: border-box;
        }

        /* Override external CSS max-width constraints */
        .screen {
            max-width: none !important;
            width: 100% !important;
        }

        body.fullscreen {
            padding: 0;
            overflow: hidden;
        }

        .grading-container {
            max-width: none;
            margin: 0;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        .grading-header {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #007bff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 123, 255, 0.2);
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .grading-header h1 {
            color: #ffffff;
            margin: 0 0 10px 0;
            font-size: 2em;
        }

        .grading-header p {
            color: #cccccc;
            margin: 0;
            font-size: 16px;
        }

        .connection-status {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #007bff;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            color: #ffffff;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .status-disconnected {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .no-games-message {
            text-align: center;
            padding: 50px;
            color: #cccccc;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #007bff;
            border-radius: 12px;
        }

        .game-selection {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #007bff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 123, 255, 0.2);
            padding: 25px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .game-selection h3 {
            color: #ffffff;
            margin: 0 0 20px 0;
            font-size: 1.5em;
        }

        .game-list {
            display: grid;
            gap: 15px;
        }

        .game-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .game-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .game-item h4 {
            color: #ffffff;
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }

        .game-item p {
            color: #cccccc;
            margin: 5px 0;
            font-size: 14px;
        }

        .grading-interface {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #007bff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 123, 255, 0.2);
            padding: 15px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            margin-bottom: 30px;
            width: 100%;
            max-width: none;
            box-sizing: border-box;
        }

        .grading-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .grading-title {
            margin: 0;
        }



        .grading-interface h3 {
            color: #ffffff;
            margin: 0 0 20px 0;
            font-size: 1.5em;
        }

        .grading-instructions {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .grading-instructions p {
            margin: 5px 0;
            font-size: 14px;
        }

        .answer-buckets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .grading-layout {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 100%;
            max-width: none;
            box-sizing: border-box;
        }

        .question-section {
            width: 100%;
            max-width: none;
        }

        .answer-buckets-section {
            width: 100%;
        }

        .categorization-section {
            width: 100%;
        }

        .correct-answers-section {
            margin-bottom: 20px;
        }

        .correct-answers-section h4 {
            color: #ffffff;
            margin: 0 0 15px 0;
            font-size: 1.2em;
            text-align: center;
        }

        .wrong-uncategorized-section {
            margin-bottom: 20px;
        }

        .wrong-uncategorized-section h4 {
            color: #ffffff;
            margin: 0 0 15px 0;
            font-size: 1.2em;
            text-align: center;
        }

        .wrong-uncategorized-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        #correctAnswers {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            grid-auto-flow: row;
        }

        .answer-bucket {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px;
            min-height: 120px; /* Changed from fixed height to min-height */
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: visible; /* Allow content to expand */
            transition: all 0.3s ease;
        }
        
        .answer-bucket.drag-over {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.2);
            box-shadow: 0 0 20px rgba(40, 167, 69, 0.4);
            transform: scale(1.02);
        }

        .answer-bucket h4 {
            color: #ffffff;
            margin: 0 0 8px 0;
            font-size: 1em;
            text-align: center;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            height: 32px;
            flex-shrink: 0;
        }

        .bucket-toggle {
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }

        .bucket-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .answer-items {
            flex: 1;
            padding: 6px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            transition: all 0.3s ease;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 80px; /* Minimum height for content area */
        }
        
        /* Larger content area for wrong/uncategorized buckets */
        .uncategorized-bucket .answer-items,
        .wrong-bucket .answer-items {
            min-height: 550px; /* Much larger content area */
        }
        
        /* Larger content area for correct answer buckets when expanded */
        .correct-bucket .answer-items:not(.collapsed) {
            min-height: 300px; /* Larger when expanded */
        }

        .answer-items.collapsed {
            min-height: 0;
            padding: 0;
            max-height: 0;
            overflow: hidden;
        }

        .answer-bucket.correct-bucket {
            border-color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
        }

        .answer-bucket.correct-bucket.empty {
            border-color: #27ae60;
            background: rgba(39, 174, 96, 0.05);
            opacity: 0.8;
        }

        .answer-bucket.correct-bucket.empty .answer-items {
            border-style: dashed;
            border-color: rgba(39, 174, 96, 0.5);
        }

        .answer-bucket.wrong-bucket {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        .answer-bucket.uncategorized-bucket {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
            min-height: 600px; /* Even taller for uncategorized buckets */
        }
        
        .answer-bucket.wrong-bucket {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            min-height: 600px; /* Even taller for wrong buckets */
        }

        .answer-items {
            min-height: 150px;
            padding: 10px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .answer-item {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 6px;
            cursor: move;
            transition: all 0.3s ease;
        }

        .answer-item:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .answer-item.dragging {
            opacity: 0.5;
        }

        .answer-text {
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 3px;
            font-size: 0.95em;
        }

        .answer-count {
            color: #cccccc;
            font-size: 11px;
        }

        .answer-players {
            color: #cccccc;
            font-size: 10px;
            margin-top: 3px;
        }

        .grading-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .grading-controls-top {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .control-btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4);
        }

        .control-btn.success {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .control-btn.primary {
            background: linear-gradient(135deg, #007bff, #0056b3);
        }

        .control-btn.warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
            color: #000;
        }

        .control-btn.secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
        }

        .drag-over {
            background: rgba(0, 123, 255, 0.2);
            border-color: #007bff;
        }

        .answer-bucket h4.drag-over {
            background: rgba(0, 123, 255, 0.3);
            border-radius: 8px;
            padding: 5px;
        }

        .answer-count-badge {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.8em;
            font-weight: bold;
            color: #ffffff;
            margin-left: 8px;
            min-width: 20px;
            text-align: center;
        }

        .answer-bucket.correct-bucket .answer-count-badge {
            background: rgba(39, 174, 96, 0.3);
            border-color: rgba(39, 174, 96, 0.5);
        }

        .answer-bucket.wrong-bucket .answer-count-badge {
            background: rgba(231, 76, 60, 0.3);
            border-color: rgba(231, 76, 60, 0.5);
        }

        .answer-bucket.uncategorized-bucket .answer-count-badge {
            background: rgba(243, 156, 18, 0.3);
            border-color: rgba(243, 156, 18, 0.5);
        }

        /* Question Display Styles */
        /* Question Display Container */
        .question-display {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #007bff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 123, 255, 0.2);
            padding: 8px;
            margin-bottom: 10px;
            backdrop-filter: blur(10px);
            width: 100%;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        /* Question Card - Main Content Area */
        .question-card {
            background: rgba(0, 123, 255, 0.1) !important;
            border: 1px solid rgba(0, 123, 255, 0.3) !important;
            border-radius: 12px !important;
            padding: 6px !important;
            width: 100% !important;
            max-width: none !important;
            box-sizing: border-box !important;
            transition: all 0.3s ease !important;
            position: static !important;
            overflow: visible !important;
            animation: none !important;
            display: block !important;
            align-items: unset !important;
            justify-content: unset !important;
            aspect-ratio: unset !important;
        }

        .question-card:hover {
            background: rgba(0, 123, 255, 0.15) !important;
            border-color: rgba(0, 123, 255, 0.4) !important;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.1) !important;
        }

        /* Remove conflicting pseudo-elements */
        .question-card::before,
        .question-card::after {
            display: none !important;
        }

        /* Question Header */
        .question-card h4 {
            color: #007bff;
            margin: 0 0 4px 0;
            font-size: 0.9em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Question Text Content */
        .question-text {
            color: #ffffff;
            font-size: 0.9em;
            line-height: 1.2;
            margin: 0 0 4px 0;
            font-weight: 500;
            word-wrap: break-word;
            hyphens: auto;
        }

        /* Question Metadata */
        .question-meta {
            display: flex;
            gap: 15px;
            color: #cccccc;
            font-size: 0.8em;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Question Number Badge */
        .question-number {
            background: rgba(0, 123, 255, 0.2);
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(0, 123, 255, 0.3);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .question-number:hover {
            background: rgba(0, 123, 255, 0.3);
            border-color: rgba(0, 123, 255, 0.5);
        }

        /* Answer Count Badge */
        .answer-count {
            background: rgba(39, 174, 96, 0.2);
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(39, 174, 96, 0.3);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .answer-count:hover {
            background: rgba(39, 174, 96, 0.3);
            border-color: rgba(39, 174, 96, 0.5);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Manual Open Button - Always visible outside the modal -->
    <button id="manualOpenBtn" class="control-btn secondary" onclick="manualOpenGrading()">Manual Open Grading</button>
    
    <div class="grading-container">
        <!-- Connection Status -->
        <div class="connection-status">
            <span class="status-indicator status-disconnected" id="connectionIndicator"></span>
            <span id="connectionStatus">Connecting to server...</span>
        </div>

        <!-- Header -->
        <div class="grading-header">
            <h1>üìù Single User Grading Interface</h1>
            <p>Drag answers to categorize them as correct or incorrect</p>
        </div>

        <!-- No Games Message -->
        <div id="noGamesMessage" class="no-games-message">
            <h3>No Active Games</h3>
            <p>There are currently no games in grading phase.</p>
        </div>

        <!-- Game Selection -->
        <div id="gameSelection" class="game-selection" style="display: none;">
            <h3>üéÆ Select Game to Grade</h3>
            <div id="gameList" class="game-list">
                <!-- Games will be populated here -->
            </div>
        </div>

        <!-- Grading Interface -->
        <div id="gradingInterface" class="grading-interface" style="display: none;">
            <div class="grading-header-controls">
                <h3 class="grading-title">üìù Categorize Answers</h3>
                <button id="resyncBtn" class="control-btn secondary" onclick="resyncGameData()">üîÑ Re-sync</button>
            </div>
            <div class="grading-controls-top">
                <button id="applyCategorizationBtn" class="control-btn success">Complete Grading</button>
                <button id="nextQuestionBtn" class="control-btn primary" style="display: none;">Next Question</button>
            </div>
            
            <div class="grading-layout">
                <!-- Question Section (Full Width) -->
                <div class="question-section">
                    <div id="questionDisplay" class="question-display" style="display: none;">
                        <div class="question-card">
                            <h4>üìã Current Question</h4>
                            <p id="questionText" class="question-text"></p>
                            <div class="question-meta">
                                <span id="questionNumber" class="question-number"></span>
                                <span id="answerCount" class="answer-count"></span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Answer Buckets Section (Full Width Grid) -->
                <div class="answer-buckets-section">
                    <div class="correct-answers-section">
                        <h4>‚úÖ Correct Answers (from database)</h4>
                        <div id="correctAnswers">
                            <!-- Correct answer buckets will be created here dynamically -->
                        </div>
                    </div>
                </div>

                <!-- Categorization Section (Full Width) -->
                <div class="categorization-section">
                    <div class="wrong-uncategorized-section">
                        <h4>‚ùå Wrong & üì¶ Uncategorized Answers</h4>
                        <div class="wrong-uncategorized-grid">
                            <!-- Uncategorized Answers Bucket -->
                            <div class="answer-bucket uncategorized-bucket" data-bucket-id="uncategorized">
                                <h4 onclick="toggleBucket(this)">
                                    <span class="bucket-toggle">‚ñº</span>
                                    üì¶ Uncategorized Answers
                                    <span class="answer-count-badge" id="uncategorizedAnswersCount">0</span>
                                </h4>
                                <div id="uncategorizedAnswers" class="answer-items" data-bucket="uncategorized" data-bucket-id="uncategorized">
                                    <!-- Uncategorized answers will be here initially -->
                                </div>
                            </div>

                            <!-- Wrong Answers Bucket -->
                            <div class="answer-bucket wrong-bucket" data-bucket-id="wrong">
                                <h4 onclick="toggleBucket(this)">
                                    <span class="bucket-toggle">‚ñº</span>
                                    ‚ùå Wrong Answers
                                    <span class="answer-count-badge" id="wrongAnswersCount">0</span>
                                </h4>
                                <div id="wrongAnswers" class="answer-items" data-bucket="wrong" data-bucket-id="wrong">
                                    <!-- Wrong answers will be dragged here -->
                                </div>
                            </div>

                    <!-- Send Back Bucket -->
                    <div class="answer-bucket sendback-bucket">
                        <h4>‚úèÔ∏è Send Back (Refine)</h4>
                        <div id="sendBackAnswers" class="answer-items" data-bucket="sendBack" data-bucket-id="sendBack">
                            <!-- Answers needing edit will be dragged here -->
                        </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let socket = null;
        let currentGame = null;
        let activeGames = [];
        let draggedElement = null;

        function initializeConnection() {
            socket = io({
                transports: ['websocket', 'polling'],
                timeout: 20000,
                forceNew: false,
                reconnection: true,
                reconnectionAttempts: 25,
                reconnectionDelay: 500,
                reconnectionDelayMax: 3000,
                maxReconnectionAttempts: 25,
                autoConnect: true
            });

            // Lightweight Q&A toast for grader
            (function ensureQaToast(){
                if (document.getElementById('graderQaToast')) return;
                const toast = document.createElement('div');
                toast.id = 'graderQaToast';
                toast.style.cssText = 'position:fixed;top:16px;right:16px;max-width:360px;background:rgba(0,0,0,0.85);color:#fff;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,.15);box-shadow:0 4px 14px rgba(0,0,0,.35);z-index:9999;display:none;font-size:14px;line-height:1.35;';
                toast.innerHTML = '<strong>New player question</strong><div id="graderQaToastText" style="margin-top:4px;opacity:.9;"></div>';
                document.body.appendChild(toast);
            })();

            const showQaToast = (msg) => {
                const toast = document.getElementById('graderQaToast');
                const text = document.getElementById('graderQaToastText');
                if (!toast || !text) return;
                text.textContent = msg;
                toast.style.display = 'block';
                clearTimeout(window.__qaToastTimer);
                window.__qaToastTimer = setTimeout(()=>{ toast.style.display = 'none'; }, 3000);
            };
            
            socket.on('connect', () => {
                updateConnectionStatus(true);
                console.log('üîå Socket connected, attempting to connect to game');
                
                // Get the game code from the parent window (host.html)
                const gameCode = window.parent.getCurrentGameCode ? window.parent.getCurrentGameCode() : null;
                if (gameCode) {
                    console.log('üéÆ Game code from parent window:', gameCode);
                    connectToHostGame(gameCode);
                } else {
                    // Fallback: try to get from URL parameters
                    const urlParams = new URLSearchParams(window.location.search);
                    const gameCodeFromUrl = urlParams.get('gameCode');
                    if (gameCodeFromUrl) {
                        console.log('üéÆ Game code from URL:', gameCodeFromUrl);
                        connectToHostGame(gameCodeFromUrl);
                    } else {
                        console.log('‚ö†Ô∏è No game code found, loading active games');
                        loadActiveGames();
                    }
                }
                
                // Set up periodic check to ensure grading interface opens
                setTimeout(() => {
                    const gradingInterface = document.getElementById('gradingInterface');
                    if (gradingInterface && gradingInterface.style.display === 'none') {
                        console.log('üîÑ Periodic check: Grading interface not visible, attempting to open');
                        const urlParams = new URLSearchParams(window.location.search);
                        const gameCode = urlParams.get('gameCode');
                        if (gameCode) {
                            autoOpenGradingInterface(gameCode);
                        }
                    }
                }, 3000);
            });
            
            socket.on('disconnect', () => {
                updateConnectionStatus(false);
            });
            
            socket.on('activeGamesUpdate', (games) => {
                activeGames = games;
                updateGameList();
            });
            
            socket.on('gameStateUpdate', (data) => {
                console.log('üîÑ Game state update received:', data);
                
                // Auto-open grading interface when question starts or grading begins
                if ((data.gameState === 'playing' || data.gameState === 'grading') && data.gameCode) {
                    autoOpenGradingInterface(data.gameCode);
                }
                
                if (!currentGame || data.gameCode !== currentGame.gameCode) return;
                
                // Update only lightweight parts to avoid wiping manual categorizations
                // Preserve local DOM placements; refresh pending edits banner
                currentGame.pendingEdits = data.pendingEdits || [];
                currentGame.currentQuestionIndex = data.currentQuestionIndex;
                currentGame.currentQuestionData = data.currentQuestionData || currentGame.currentQuestionData;
                
                // CRITICAL FIX: Update answer groups when they change (like after clarifications)
                if (data.currentAnswerGroups && Array.isArray(data.currentAnswerGroups)) {
                    console.log('üîÑ Updating answer groups from gameStateUpdate:', data.currentAnswerGroups.length, 'groups');
                    currentGame.currentAnswerGroups = data.currentAnswerGroups;
                    // Trigger a smooth update to reflect the new answers
                    updateAnswerBucketsSmoothly();
                }
                
                // CRITICAL FIX: Show pending edits in grading interface
                try {
                    if (Array.isArray(data.pendingEdits) && data.pendingEdits.length > 0) {
                        console.log('‚úèÔ∏è Updating pending edits banner:', data.pendingEdits);
                        let notice = document.getElementById('pendingEditsNotice');
                        if (!notice) {
                            notice = document.createElement('div');
                            notice.id = 'pendingEditsNotice';
                            notice.style.cssText = 'margin:8px 0;padding:8px 12px;border:1px solid rgba(241,196,15,.4);background:rgba(241,196,15,.12);border-radius:8px;color:#b9770e;';
                            notice.innerHTML = '<strong>‚è≥ Pending clarifications:</strong> <span id="pendingEditsList"></span>';
                            document.querySelector('#gradingInterface')?.prepend(notice);
                        }
                        const listEl = document.getElementById('pendingEditsList');
                        if (listEl) {
                            listEl.textContent = data.pendingEdits.map(p=>`${p.playerName} ("${p.originalAnswer}")`).join(', ');
                        }
                    } else {
                        const notice = document.getElementById('pendingEditsNotice');
                        if (notice && notice.parentNode) notice.parentNode.removeChild(notice);
                    }
                } catch (_) {}
                
                try {
                    if (Array.isArray(currentGame.pendingEdits) && currentGame.pendingEdits.length > 0) {
                        const notice = document.getElementById('pendingEditsNotice') || (function(){
                            const n = document.createElement('div');
                            n.id = 'pendingEditsNotice';
                            n.style.cssText = 'margin:8px 0;padding:8px 12px;border:1px solid rgba(241,196,15,.4);background:rgba(241,196,15,.12);border-radius:8px;color:#b9770e;';
                            n.innerHTML = '<strong>Pending clarifications:</strong> <span id="pendingEditsList"></span>';
                            document.querySelector('#gradingInterface')?.prepend(n);
                            return n;
                        })();
                        const listEl = document.getElementById('pendingEditsList');
                        if (listEl) listEl.textContent = currentGame.pendingEdits.map(p=>`${p.playerName} ("${p.originalAnswer}")`).join(', ');
                    } else {
                        const n = document.getElementById('pendingEditsNotice');
                        if (n && n.parentNode) n.parentNode.removeChild(n);
                    }
                } catch (_) {}
                
                // Do not re-render buckets here to preserve manual categorization
            });
            
            socket.on('gameStateResponse', (data) => {
                if (data && data.gameCode) {
                    currentGame = data;
                    // Hide the game selection and show the grading interface
                    document.getElementById('gameSelection').style.display = 'none';
                    document.getElementById('noGamesMessage').style.display = 'none';
                    document.getElementById('gradingInterface').style.display = 'block';
                    try {
                        if (Array.isArray(data.pendingEdits) && data.pendingEdits.length > 0) {
                            const notice = document.getElementById('pendingEditsNotice') || (function(){
                                const n = document.createElement('div');
                                n.id = 'pendingEditsNotice';
                                n.style.cssText = 'margin:8px 0;padding:8px 12px;border:1px solid rgba(241,196,15,.4);background:rgba(241,196,15,.12);border-radius:8px;color:#b9770e;';
                                n.innerHTML = '<strong>Pending clarifications:</strong> <span id="pendingEditsList"></span>';
                                document.querySelector('#gradingInterface')?.prepend(n);
                                return n;
                            })();
                            const listEl = document.getElementById('pendingEditsList');
                            if (listEl) listEl.textContent = data.pendingEdits.map(p=>`${p.playerName} ("${p.originalAnswer}")`).join(', ');
                        } else {
                            const n = document.getElementById('pendingEditsNotice');
                            if (n && n.parentNode) n.parentNode.removeChild(n);
                        }
                    } catch (_) {}
                    updateGradingInterface();
                } else {
                    // If no game found, fall back to showing available games
                    console.log('No specific game found, showing available games');
                    loadActiveGames();
                }
            });
            
            socket.on('error', (error) => {
                console.error('Socket error:', error);
                alert('Error: ' + error.message);
            });
            
            socket.on('gradingComplete', (data) => {
                console.log('üéØüéØüéØ GRADING COMPLETE EVENT RECEIVED! üéØüéØüéØ', data);
                
                // Auto-close this grading interface immediately
                console.log('üéØ About to close window...');
                console.log('üéØ window.opener exists:', !!window.opener);
                console.log('üéØ window.parent exists:', !!window.parent);
                console.log('üéØ window.parent !== window:', window.parent !== window);
                
                // Try multiple methods to close/return to host
                try {
                    if (window.opener && !window.opener.closed) {
                        console.log('üéØ Method 1: Closing popup via window.opener');
                        window.opener.focus();
                        window.close();
                    } else if (window.parent && window.parent !== window) {
                        console.log('üéØ Method 2: Closing iframe/embedded window');
                        window.parent.postMessage('closeGradingInterface', '*');
                        try { window.close(); } catch (_) {}
                    } else {
                        console.log('üéØ Method 3: Direct navigation to host');
                        window.location.href = '/host';
                    }
                } catch (error) {
                    console.error('üéØ Error closing grading interface:', error);
                    // Fallback
                    window.location.href = '/host';
                }
            });

            // Q&A: notify grader when a player question arrives
            socket.on('playerQuestion', (payload) => {
                try {
                    if (!payload || !payload.playerName || !payload.question) return;
                    showQaToast(`${payload.playerName}: ${payload.question}`);
                } catch (_) {}
            });

            // Real-time answer updates
            socket.on('newAnswerSubmitted', (data) => {
                console.log('üìù New answer submitted in real-time:', data);
                console.log('üìù Socket ID receiving event:', socket.id);
                console.log('üìù Current game state:', currentGame ? currentGame.gameCode : 'none');
                console.log('üìù Current answer groups:', currentGame ? currentGame.currentAnswerGroups : 'none');
                console.log('üìù Event data gameCode:', data.gameCode);
                console.log('üìù Event data playerName:', data.playerName);
                console.log('üìù Event data answer:', data.answer);
                
                // Treat this submission as clearing any pending clarification for this player
                try {
                    if (currentGame && Array.isArray(currentGame.pendingEdits)) {
                        const before = currentGame.pendingEdits.length;
                        currentGame.pendingEdits = currentGame.pendingEdits.filter(p => String(p.playerName || '').toLowerCase() !== String(data.playerName || '').toLowerCase());
                        if (currentGame.pendingEdits.length !== before) {
                            const n = document.getElementById('pendingEditsNotice');
                            const listEl = document.getElementById('pendingEditsList');
                            if (currentGame.pendingEdits.length === 0) {
                                if (n && n.parentNode) n.parentNode.removeChild(n);
                            } else if (listEl) {
                                listEl.textContent = currentGame.pendingEdits.map(p=>`${p.playerName} ("${p.originalAnswer}")`).join(', ');
                            }
                        }
                    }
                } catch (_) {}

                // Update the current game with the new answer WITHOUT resetting manual categorizations
                if (currentGame && currentGame.currentAnswerGroups) {
                    // Find any existing group(s) that already contain this player's name (case-insensitive)
                    const lowerName = String(data.playerName || '').toLowerCase();
                    const groupsWithPlayer = (currentGame.currentAnswerGroups || []).filter(g =>
                        Array.isArray(g.players) && g.players.some(p => String(p).toLowerCase() === lowerName)
                    );

                    if (groupsWithPlayer.length === 0) {
                        // Add new group for this player's first submission
                        console.log('‚ûï Adding new answer group for player:', data.playerName);
                        currentGame.currentAnswerGroups.push({
                            answer: data.answer,
                            players: [data.playerName],
                            count: 1,
                            points: 0,
                            index: currentGame.currentAnswerGroups.length
                        });
                    } else {
                        // Update the text on the player's existing group, but do not drop other players in that group
                        // If multiple groups already exist for the same normalized text due to prior consolidation,
                        // consolidate them first to avoid overwriting counts.
                        const norm = (txt) => String(txt || '').toLowerCase().trim();
                        let targetGroup = groupsWithPlayer[0];
                        try {
                            const sameTextGroups = (currentGame.currentAnswerGroups || []).filter(g => norm(g.answer) === norm(targetGroup.answer));
                            if (sameTextGroups.length > 1) {
                                const mergedPlayers = Array.from(new Set(sameTextGroups.flatMap(g => g.players || [])));
                                sameTextGroups[0].players = mergedPlayers;
                                sameTextGroups[0].count = mergedPlayers.length;
                                // Remove duplicates from data list
                                currentGame.currentAnswerGroups = currentGame.currentAnswerGroups.filter(g => g === sameTextGroups[0] || norm(g.answer) !== norm(targetGroup.answer));
                                targetGroup = sameTextGroups[0];
                            }
                        } catch (_) {}
                        console.log('üîÑ Updating existing player answer text without altering grouped players:', data.playerName);
                        targetGroup.answer = data.answer;
                    }
                    
                    // Update only the affected DOM bucket if it exists; otherwise place in Uncategorized
                    try {
                        const affectedName = data.playerName;
                        const group = currentGame.currentAnswerGroups.find(g => g.players && g.players.includes(affectedName));
                        const correctAnswers = (currentGame.currentQuestionData?.correct_answers || []).slice();
                        const normalized = (group?.answer || '').toLowerCase().trim();
                        const matchingCorrect = correctAnswers.find(c => c.toLowerCase().trim() === normalized);
                        if (matchingCorrect) {
                            // Ensure correct bucket exists and reflect updated players/answer
                        const bucketId = `bucket-${matchingCorrect.toLowerCase().replace(/\s+/g, '-')}`;
                            let bucket = document.getElementById(bucketId);
                            if (!bucket) {
                                bucket = createAnswerBucket(matchingCorrect, group || { players:[affectedName], count:1 });
                                bucket.id = bucketId;
                                document.getElementById('correctAnswers').appendChild(bucket);
                            }
                            // Consolidate groups for the same normalized answer into a single combined players list
                            try {
                                const norm = (txt) => String(txt || '').toLowerCase().trim();
                                const sameGroups = (currentGame.currentAnswerGroups || []).filter(g => norm(g.answer) === norm(group?.answer));
                            // Merge player lists across groups without dropping anyone
                            const combinedPlayers = Array.from(new Set(sameGroups.flatMap(g => g.players || []).map(p => String(p))));
                                // Update one canonical group and remove duplicates from data
                                if (sameGroups.length > 0) {
                                    sameGroups[0].players = combinedPlayers;
                                    sameGroups[0].count = combinedPlayers.length;
                                    currentGame.currentAnswerGroups = currentGame.currentAnswerGroups.filter(g => g === sameGroups[0] || norm(g.answer) !== norm(group?.answer));
                                    group = sameGroups[0];
                                } else {
                                    group.players = combinedPlayers.length ? combinedPlayers : (group.players || [affectedName]);
                                    group.count = group.players.length;
                                }
                            } catch(_) {}
                            // Remove this player from uncategorized DOM if present
                            try {
                                const unc = document.getElementById('uncategorizedAnswers');
                                if (unc) {
                                    Array.from(unc.querySelectorAll('.answer-players')).forEach(el => {
                                        const names = (el.textContent || '').split(',').map(s=>s.trim().toLowerCase());
                                        if (names.includes(String(affectedName).toLowerCase())) {
                                            const item = el.closest('.answer-item');
                                            if (item) item.remove();
                                        }
                                    });
                                }
                            } catch(_) {}
                            updateBucketAnswerList(bucket, group);
                            // If this exact answer text already exists as another item, merge names and remove duplicate item
                            try {
                                const items = Array.from(bucket.querySelectorAll('.answer-item'));
                                const sameText = items.filter(it => (it.dataset.answerText || '').toLowerCase().trim() === (group?.answer || '').toLowerCase().trim());
                                if (sameText.length > 1) {
                                    // Merge players into a single DOM item; keep first, merge names, remove duplicates
                                    const canonical = sameText[0].querySelector('.answer-players');
                                    const canonicalNames = new Set((canonical?.textContent || '').split(',').map(s=>s.trim()).filter(Boolean));
                                    sameText.slice(1).forEach(dup => {
                                        const namesEl = dup.querySelector('.answer-players');
                                        (namesEl?.textContent || '').split(',').map(s=>s.trim()).filter(Boolean).forEach(n=>canonicalNames.add(n));
                                        dup.remove();
                                    });
                                    if (canonical) canonical.textContent = Array.from(canonicalNames).join(', ');
                                }
                            } catch(_) {}
                            updateCountBadges();
                        } else {
                            // Move/update in Uncategorized only if not already categorized manually
                            // If the player is currently listed in any correct/wrong bucket DOM, skip auto-move
                            let listedSomewhere = false;
                            try {
                                const playerEls = Array.from(document.querySelectorAll('.answer-players'));
                                for (const el of playerEls) {
                                    if ((el.textContent || '').split(',').map(s => s.trim().toLowerCase()).includes(String(affectedName).toLowerCase())) {
                                        // If this element is inside uncategorized, allow update there; otherwise treat as categorized
                                        const parentBucket = el.closest('.answer-bucket');
                                        const isUncategorized = parentBucket && parentBucket.classList.contains('uncategorized-bucket');
                                        if (!isUncategorized) { listedSomewhere = true; }
                                        break;
                                    }
                                }
                            } catch(_) {}
                            if (!listedSomewhere) {
                                const unc = document.getElementById('uncategorizedAnswers');
                                if (unc) {
                                    // Remove any previous item for this player's old answer
                                    Array.from(unc.children).forEach(ch => {
                                        if ((ch.dataset?.answerText || '') && (group?.answer || '') && ch.dataset.answerText.toLowerCase().trim() === group.answer.toLowerCase().trim()) {
                                            ch.remove();
                                        }
                                    });
                                    const newItem = createAnswerItem({ answer: group?.answer || data.answer, players:[affectedName], semanticConfidence: group?.semanticConfidence, semanticMatch: group?.semanticMatch }, 0);
                                    unc.appendChild(newItem);
                                    updateCountBadges();
                                }
                            }
                        }
                    } catch (e) { console.warn('Failed partial DOM update for new answer', e); }
                } else {
                    console.log('‚ö†Ô∏è Cannot update: no current game or answer groups');
                }
            });

            // Auto-open grading interface when question starts
            socket.on('nextQuestion', (data) => {
                console.log('üéØ Question started, auto-opening grading interface:', data);
                console.log('üéØ nextQuestion event received with gameCode:', data?.gameCode);
                if (data && data.gameCode) {
                    console.log('üéØ Calling autoOpenGradingInterface for gameCode:', data.gameCode);
                    autoOpenGradingInterface(data.gameCode);
                } else {
                    console.log('‚ö†Ô∏è nextQuestion event missing gameCode:', data);
                }
            });

            // Auto-open grading interface when game starts (first question)
            socket.on('gameStarted', (data) => {
                console.log('üéÆ Game started, auto-opening grading interface for first question:', data);
                console.log('üéÆ gameStarted event received with gameCode:', data?.gameCode);
                if (data && data.gameCode) {
                    console.log('üéÆ Calling autoOpenGradingInterface for gameCode:', data.gameCode);
                    autoOpenGradingInterface(data.gameCode);
                } else {
                    console.log('‚ö†Ô∏è gameStarted event missing gameCode:', data);
                }
            });


        }

        function connectToHostGame(gameCode) {
            console.log('üîó Connecting to host game:', gameCode);
            console.log('üîó Socket ID:', socket.id);
            
            // First, identify as the host for this game
            console.log('üîó Emitting host-reconnect for game:', gameCode);
            socket.emit('host-reconnect', { gameCode: gameCode });
            
            // Join the game room to receive real-time updates
            console.log('üîó Emitting joinGameRoom for game:', gameCode);
            socket.emit('joinGameRoom', { gameCode: gameCode });
            
            // Then request the specific game state
            console.log('üîó Emitting getGameState for game:', gameCode);
            socket.emit('getGameState', { gameCode: gameCode });
            
            // Also try to get active games as a fallback
            setTimeout(() => {
                console.log('üîó Emitting getActiveGames as fallback');
                socket.emit('getActiveGames');
            }, 1000);
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionIndicator');
            const status = document.getElementById('connectionStatus');
            
            if (connected) {
                indicator.className = 'status-indicator status-connected';
                status.textContent = 'Connected to server';
            } else {
                indicator.className = 'status-indicator status-disconnected';
                status.textContent = 'Disconnected from server';
            }
        }

        function loadActiveGames() {
            socket.emit('getActiveGames');
        }

        function updateGameList() {
            const noGamesMessage = document.getElementById('noGamesMessage');
            const gameSelection = document.getElementById('gameSelection');
            const gameList = document.getElementById('gameList');
            
            const gradingGames = activeGames.filter(game => game.gameState === 'grading');
            
            if (gradingGames.length === 0) {
                noGamesMessage.style.display = 'block';
                gameSelection.style.display = 'none';
                return;
            }
            
            noGamesMessage.style.display = 'none';
            gameSelection.style.display = 'block';
            
            gameList.innerHTML = '';
            
            gradingGames.forEach(game => {
                const gameItem = document.createElement('div');
                gameItem.className = 'game-item';
                gameItem.onclick = () => selectGame(game);
                gameItem.innerHTML = `
                    <h4>Game ${game.gameCode}</h4>
                    <p>Host: ${game.hostId}</p>
                    <p>Players: ${game.playerCount || game.players.length}</p>
                    <p>Status: ${game.gameState}</p>
                `;
                gameList.appendChild(gameItem);
            });
        }

        function updateQuestionDisplay() {
            const questionDisplay = document.getElementById('questionDisplay');
            const questionText = document.getElementById('questionText');
            const questionNumber = document.getElementById('questionNumber');
            const answerCount = document.getElementById('answerCount');
            
            if (currentGame && currentGame.currentQuestionData) {
                const questionData = currentGame.currentQuestionData;
                
                // Show question display
                questionDisplay.style.display = 'block';
                
                // Update question text
                questionText.textContent = questionData.prompt || 'No question text available';
                
                // Update question number
                questionNumber.textContent = `Question ${currentGame.currentQuestion + 1}`;
                
                // Update answer count (total responses, not unique answer texts)
                const totalResponses = Array.isArray(currentGame.currentAnswerGroups)
                    ? currentGame.currentAnswerGroups.reduce((sum, g) => {
                        if (Array.isArray(g.players)) return sum + g.players.length;
                        if (typeof g.count === 'number') return sum + g.count;
                        return sum;
                    }, 0)
                    : 0;
                answerCount.textContent = `${totalResponses} response${totalResponses !== 1 ? 's' : ''}`;
            } else {
                // Hide question display if no question data
                questionDisplay.style.display = 'none';
            }
        }

        function manualOpenGrading() {
            console.log('üîß Manual grading interface open requested');
            const urlParams = new URLSearchParams(window.location.search);
            const gameCode = urlParams.get('gameCode');
            if (gameCode) {
                autoOpenGradingInterface(gameCode);
            } else {
                alert('No game code found in URL. Please ensure you accessed this page with a game code.');
            }
        }

        function autoOpenGradingInterface(gameCode) {
            console.log('üîÑ Auto-opening grading interface for game:', gameCode);
            
            // Connect to the game and open grading interface automatically
            connectToHostGame(gameCode);
            
            // Force the grading interface to be visible
            const gradingInterface = document.getElementById('gradingInterface');
            const gameSelection = document.getElementById('gameSelection');
            const noGamesMessage = document.getElementById('noGamesMessage');
            
            if (gradingInterface) {
                gradingInterface.style.display = 'block';
                console.log('‚úÖ Grading interface made visible');
            }
            
            if (gameSelection) {
                gameSelection.style.display = 'none';
            }
            
            if (noGamesMessage) {
                noGamesMessage.style.display = 'none';
            }
            
            // Focus the window to bring attention to the grading interface
            if (window.focus) {
                window.focus();
            }
            
            // Show a notification if the window is not focused
            if (!document.hasFocus()) {
                // Create a notification sound or visual indicator
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #007bff;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    animation: slideIn 0.3s ease-out;
                `;
                notification.innerHTML = `
                    <strong>üìù Grading Required!</strong><br>
                    Question started for Game ${gameCode}
                `;
                document.body.appendChild(notification);
                
                // Remove notification after 5 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 5000);
            }
        }

        function selectGame(game) {
            currentGame = game;
            document.getElementById('gameSelection').style.display = 'none';
            document.getElementById('gradingInterface').style.display = 'block';
            updateGradingInterface().catch(error => {
                console.error('Error updating grading interface:', error);
            });
        }

        async function updateGradingInterface() {
            if (!currentGame || !currentGame.currentAnswerGroups) return;
            
            console.log('üîÑ Updating grading interface for question:', currentGame.currentQuestionIndex);
            
            // CRITICAL: Clear grading states from previous questions to prevent wrong answers from persisting
            clearPreviousGradingStates();
            
            // Update question display
            updateQuestionDisplay();
            
            // Clear all buckets
            document.getElementById('correctAnswers').innerHTML = '';
            document.getElementById('wrongAnswers').innerHTML = '';
            document.getElementById('uncategorizedAnswers').innerHTML = '';
            
            // Reset count badges
            document.getElementById('wrongAnswersCount').textContent = '0';
            document.getElementById('uncategorizedAnswersCount').textContent = '0';
            
            await populateGradingInterface();
        }

        async function updateGradingInterfaceSmoothly() {
            if (!currentGame || !currentGame.currentAnswerGroups) return;
            
            console.log('üîÑ Smooth update: updating grading interface for question:', currentGame.currentQuestionIndex);
            
            // Clear previous question states in case this is triggered by question transition
            clearPreviousGradingStates();
            
            // Update question display
            updateQuestionDisplay();
            
            // Smoothly update only the buckets that need changes
            await updateAnswerBucketsSmoothly();
            
            // Update count badges
            updateCountBadges();
        }
        
        async function updateAnswerBucketsSmoothly() {
            if (!currentGame || !currentGame.currentQuestionData) return;
            
            const correctAnswers = (currentGame.currentQuestionData.correct_answers || []).slice().sort();
            const correctAnswersContainer = document.getElementById('correctAnswers');
            const uncategorizedContainer = document.getElementById('uncategorizedAnswers');
            
            if (!correctAnswersContainer || !uncategorizedContainer) return;
            
            // Check if this is the first real-time update (clear initial buckets)
            if (!window.smoothUpdateInitialized) {
                console.log('üîÑ First real-time update - clearing initial buckets');
                correctAnswersContainer.innerHTML = '';
                window.smoothUpdateInitialized = true;
            }
            
            // Get current answer groups
            const answerGroups = currentGame.currentAnswerGroups || [];
            
            // Create a map of answers that should be in correct buckets
            const correctAnswerMap = new Map();
            console.log('üîç Creating correct answer map:', {
                answerGroups: answerGroups,
                correctAnswers: correctAnswers
            });
            
            // Group answers by their normalized correct answer
            const groupedAnswers = new Map();
            answerGroups.forEach(group => {
                const normalizedAnswer = group.answer.toLowerCase().trim();
                const matchingCorrectAnswer = correctAnswers.find(correct => 
                    correct.toLowerCase().trim() === normalizedAnswer
                );
                console.log(`üîç Checking answer "${group.answer}":`, {
                    normalizedAnswer: normalizedAnswer,
                    matchingCorrectAnswer: matchingCorrectAnswer,
                    players: group.players,
                    totalResponses: group.totalResponses
                });
                if (matchingCorrectAnswer) {
                    if (!groupedAnswers.has(matchingCorrectAnswer)) {
                        groupedAnswers.set(matchingCorrectAnswer, {
                            answer: matchingCorrectAnswer,
                            players: [],
                            count: 0,
                            totalResponses: 0
                        });
                    }
                    const combinedGroup = groupedAnswers.get(matchingCorrectAnswer);
                    combinedGroup.players.push(...(group.players || []));
                    combinedGroup.count = combinedGroup.players.length;
                    combinedGroup.totalResponses = (group.totalResponses || 0) + combinedGroup.totalResponses;
                    
                    // Add semantic confidence calculation for real-time updates
                    if (!group.semanticConfidence) {
                        // Calculate confidence if not already calculated
                        const confidence = calculateSemanticConfidence(group.answer, matchingCorrectAnswer);
                        group.semanticConfidence = confidence;
                        group.semanticMatch = matchingCorrectAnswer;
                        console.log(`üß† Calculated confidence for "${group.answer}": ${confidence}%`);
                    }
                    
                    console.log(`‚úÖ Combined "${group.answer}" into "${matchingCorrectAnswer}"`);
                }
            });
            
            // Convert grouped answers to the map
            groupedAnswers.forEach((combinedGroup, correctAnswer) => {
                correctAnswerMap.set(correctAnswer, combinedGroup);
            });
            console.log('üîç Final correct answer map:', Array.from(correctAnswerMap.entries()).map(([key, value]) => ({
                correctAnswer: key,
                answerGroup: JSON.stringify(value)
            })));
            
            // Update each correct answer bucket smoothly
            correctAnswers.forEach(correctAnswer => {
                const bucketId = `bucket-${correctAnswer.toLowerCase().replace(/\s+/g, '-')}`;
                let bucket = document.getElementById(bucketId);
                const answerGroup = correctAnswerMap.get(correctAnswer);
                
                if (answerGroup) {
                    // Answer exists - update or create bucket
                    if (!bucket) {
                        // Create new bucket with smooth animation
                        bucket = createAnswerBucket(correctAnswer, answerGroup);
                        bucket.id = bucketId;
                        bucket.style.opacity = '0';
                        bucket.style.transform = 'scale(0.8)';
                        correctAnswersContainer.appendChild(bucket);
                        
                        // Animate in
                        setTimeout(() => {
                            bucket.style.transition = 'all 0.3s ease';
                            bucket.style.opacity = '1';
                            bucket.style.transform = 'scale(1)';
                        }, 10);
                    } else {
                        // Update existing bucket count smoothly
                        const countElement = bucket.querySelector('.answer-count-badge');
                        if (countElement) {
                            const oldCount = parseInt(countElement.textContent) || 0;
                            const newCount = answerGroup.totalResponses || (answerGroup.players ? answerGroup.players.length : 0);
                            
                            console.log(`üî¢ Updating count for bucket:`, {
                                oldCount,
                                newCount,
                                answerGroup: JSON.stringify(answerGroup)
                            });
                            
                            if (oldCount !== newCount) {
                                // Animate count change
                                countElement.style.transform = 'scale(1.2)';
                                countElement.style.color = '#4CAF50';
                                setTimeout(() => {
                                    countElement.textContent = newCount;
                                    countElement.style.transform = 'scale(1)';
                                    countElement.style.color = '';
                                }, 150);
                            }
                        }
                        
                        // Update answer list
                        updateBucketAnswerList(bucket, answerGroup);
                    }
                } else {
                    // No answers for this bucket - ensure it exists with count 0
                    if (!bucket) {
                        bucket = createAnswerBucket(correctAnswer, { count: 0, players: [] });
                        bucket.id = bucketId;
                        bucket.style.opacity = '0';
                        bucket.style.transform = 'scale(0.8)';
                        correctAnswersContainer.appendChild(bucket);
                        
                        setTimeout(() => {
                            bucket.style.transition = 'all 0.3s ease';
                            bucket.style.opacity = '1';
                            bucket.style.transform = 'scale(1)';
                        }, 10);
                    }
                }
            });
            
            // Update uncategorized answers
            const uncategorizedAnswers = answerGroups.filter(group => {
                const normalizedAnswer = group.answer.toLowerCase().trim();
                return !correctAnswers.some(correct => 
                    correct.toLowerCase().trim() === normalizedAnswer
                );
            });
            
            // Calculate confidence scores for uncategorized answers in real-time updates
            uncategorizedAnswers.forEach(answerGroup => {
                if (!answerGroup.semanticConfidence) {
                    // Find the best matching correct answer for confidence calculation
                    let bestConfidence = 0;
                    let bestMatch = null;
                    
                    correctAnswers.forEach(correctAnswer => {
                        const confidence = calculateSemanticConfidence(answerGroup.answer, correctAnswer);
                        if (confidence > bestConfidence) {
                            bestConfidence = confidence;
                            bestMatch = correctAnswer;
                        }
                    });
                    
                    // Set confidence data for uncategorized answers
                    answerGroup.semanticConfidence = bestConfidence;
                    answerGroup.semanticMatch = bestMatch;
                    
                    console.log(`üß† Real-time confidence for uncategorized "${answerGroup.answer}": ${bestConfidence}% ‚Üí "${bestMatch}"`);
                }
            });
            
            // Clear and repopulate uncategorized (guard against duplicate fills)
            uncategorizedContainer.innerHTML = '';
            window.skipPopulateUncategorized = false;
            await populateUncategorizedAnswers();
            
            // Re-setup drag and drop for all new elements
            setupDragAndDrop();
        }
        
        function createAnswerBucket(correctAnswer, answerGroup) {
            const bucket = document.createElement('div');
            
            // Calculate the correct player count
            let playerCount = 0;
            let playerNames = [];
            
            if (answerGroup.players && Array.isArray(answerGroup.players)) {
                playerCount = answerGroup.players.length;
                playerNames = answerGroup.players;
            } else if (answerGroup.count && typeof answerGroup.count === 'number') {
                // Fallback to count field if players array is not available
                playerCount = answerGroup.count;
                playerNames = answerGroup.players || [];
            } else if (answerGroup.totalResponses && typeof answerGroup.totalResponses === 'number') {
                // Fallback to totalResponses if count is not available
                playerCount = answerGroup.totalResponses;
                playerNames = answerGroup.players || [];
            }
            
            const isEmpty = playerCount === 0;
            
            console.log(`üî¢ Creating bucket for ${correctAnswer}:`, {
                players: answerGroup.players,
                playersLength: answerGroup.players ? answerGroup.players.length : 0,
                count: answerGroup.count,
                totalResponses: answerGroup.totalResponses,
                finalPlayerCount: playerCount,
                playerNames: playerNames,
                answerGroup: JSON.stringify(answerGroup)
            });
            
            bucket.className = `answer-bucket correct-bucket${isEmpty ? ' empty' : ''}`;
            bucket.setAttribute('data-bucket-id', `correct_${correctAnswer.toLowerCase().replace(/\s+/g, '_')}`);
            bucket.innerHTML = `
                <h4 onclick="toggleBucket(this)">
                    <span class="bucket-toggle collapsed">‚ñ∂</span>
                    ‚úÖ ${correctAnswer} <span class="answer-count-badge">${playerCount}</span>
                </h4>
                <div class="answer-items collapsed" data-bucket="${correctAnswer.toLowerCase().replace(/\s+/g, '-')}">
                    ${playerCount > 0 ? 
                        createAnswerItemHTML(correctAnswer, playerCount, 100, playerNames.join(', ')) : ''
                    }
                </div>
            `;
            return bucket;
        }
        
        function updateBucketAnswerList(bucket, answerGroup) {
            const answersContainer = bucket.querySelector('.answer-items');
            if (!answersContainer) return;
            
            // Calculate the correct player count (same logic as createAnswerBucket)
            let playerCount = 0;
            let playerNames = [];
            
            if (answerGroup.players && Array.isArray(answerGroup.players)) {
                playerCount = answerGroup.players.length;
                playerNames = answerGroup.players;
            } else if (answerGroup.count && typeof answerGroup.count === 'number') {
                playerCount = answerGroup.count;
                playerNames = answerGroup.players || [];
            } else if (answerGroup.totalResponses && typeof answerGroup.totalResponses === 'number') {
                playerCount = answerGroup.totalResponses;
                playerNames = answerGroup.players || [];
            }
            
            const currentAnswers = Array.from(answersContainer.children).map(item => 
                item.querySelector('.answer-players')?.textContent.trim()
            ).filter(Boolean);
            const newAnswers = playerNames;
            
            // Only update if answers changed
            if (JSON.stringify(currentAnswers) !== JSON.stringify(newAnswers)) {
                answersContainer.innerHTML = playerCount > 0 ? 
                    createAnswerItemHTML(answerGroup.answer, playerCount, answerGroup.semanticConfidence || 100, playerNames.join(', ')) : '';
                
                // Re-setup drag and drop for the updated bucket
                setupDragAndDrop();
            }
        }

        async function populateGradingInterface() {
            
            // Get the current question to access correct answers
            const questionData = currentGame.currentQuestionData;
            const correctAnswerList = questionData?.correct_answers || [];
            
            console.log('üîç Current question data:', questionData);
            console.log('‚úÖ Correct answers from DB:', correctAnswerList);
            console.log('üìä Current answer groups from server:', currentGame.currentAnswerGroups);
            console.log('üéØ Current question index:', currentGame.currentQuestionIndex);
            
            // CRITICAL DEBUG: Check if answer groups contain old data
            if (currentGame.currentAnswerGroups && currentGame.currentAnswerGroups.length > 0) {
                console.log('‚ö†Ô∏è DEBUGGING ANSWER SOURCE:');
                currentGame.currentAnswerGroups.forEach((group, index) => {
                    console.log(`  Answer ${index + 1}: "${group.answer}" - Players: ${group.players?.join(', ') || 'unknown'} - Count: ${group.count}`);
                });
            }
            
                // Create correct answer buckets and sort alphabetically
            const correctAnswerBuckets = correctAnswerList.map((correctAnswer, index) => ({
                id: `correct_${correctAnswer.toLowerCase().replace(/\s+/g, '_')}`,
                name: correctAnswer,
                correctAnswer: correctAnswer,
                answers: []
            })).sort((a, b) => a.name.localeCompare(b.name));
            
            console.log('üìù Sorted bucket order:', correctAnswerBuckets.map(b => b.name));
            
            // Get responses for semantic matching
                // De-duplicate identical responses so we don't double-create buckets during refresh churn
                const responses = Array.from(new Set((currentGame.currentAnswerGroups || []).map(group => group.answer)));
            const answersToRemove = [];
            
            try {
                // Call semantic matcher service
                const semanticMatches = await getSemanticMatches(
                    questionData?.prompt || '', 
                    correctAnswerList, 
                    responses
                );
                
                console.log('üß† Semantic matches:', semanticMatches);
                
                // Process semantic matches
                semanticMatches.forEach(match => {
                    const answerGroup = (currentGame.currentAnswerGroups || []).find(group => group.answer === match.response);
                    if (!answerGroup) return;
                    
                    if (match.confidence >= 90 && match.best_match) {
                        // Auto-categorize high confidence matches
                        const matchingBucket = correctAnswerBuckets.find(bucket => 
                            bucket.correctAnswer === match.best_match
                        );
                        
                        if (matchingBucket) {
                            // Add semantic confidence info to the answer group
                            answerGroup.semanticConfidence = match.confidence;
                            answerGroup.semanticMatch = match.best_match;
                            
                            matchingBucket.answers.push(answerGroup);
                            answersToRemove.push(answerGroup.answer);
                            console.log(`‚úÖ Auto-categorized "${answerGroup.answer}" to "${matchingBucket.name}" (${match.confidence}% confidence)`);
                        }
                    } else if (match.confidence >= 50) {
                        // Add confidence info for medium confidence matches
                        answerGroup.semanticConfidence = match.confidence;
                        answerGroup.semanticMatch = match.best_match;
                        console.log(`‚ö†Ô∏è Medium confidence: "${answerGroup.answer}" -> "${match.best_match}" (${match.confidence}%)`);
                    }
                });
                
            } catch (error) {
                console.error('‚ùå Semantic matching failed, falling back to exact matching:', error);
                
                // Fallback to local semantic matching
                (currentGame.currentAnswerGroups || []).forEach(answerGroup => {
                    let bestMatch = null;
                    let bestConfidence = 0;
                    
                    // Try each correct answer
                    // Sort buckets alphabetically before rendering
            correctAnswerBuckets.sort((a, b) => a.name.localeCompare(b.name));
            correctAnswerBuckets.forEach(bucket => {
                        const confidence = calculateSemanticConfidence(answerGroup.answer, bucket.correctAnswer);
                        if (confidence > bestConfidence) {
                            bestConfidence = confidence;
                            bestMatch = bucket;
                        }
                    });
                    
                    // Auto-categorize if confidence is high enough
                    if (bestMatch && bestConfidence >= 90) {
                        answerGroup.semanticConfidence = bestConfidence;
                        answerGroup.semanticMatch = bestMatch.correctAnswer;
                        bestMatch.answers.push(answerGroup);
                        answersToRemove.push(answerGroup.answer);
                        console.log(`‚úÖ Local match: "${answerGroup.answer}" to "${bestMatch.correctAnswer}" (${bestConfidence}% confidence)`);
                    }
                });
            }
            
            // Render ALL correct answer buckets (even empty ones)
            // Sort buckets alphabetically before rendering
            correctAnswerBuckets.sort((a, b) => a.name.localeCompare(b.name));
            // Clear container first to ensure no duplicates remain from previous renders
            const correctAnswersRoot = document.getElementById('correctAnswers');
            if (correctAnswersRoot) correctAnswersRoot.innerHTML = '';
            correctAnswerBuckets.forEach(bucket => {
                const bucketDiv = document.createElement('div');
                const bucketId = `bucket-${bucket.name.toLowerCase().replace(/\s+/g, '-')}`;
                
                // Calculate total player count for this bucket
                let totalPlayerCount = 0;
                bucket.answers.forEach(answerGroup => {
                    if (answerGroup.players && Array.isArray(answerGroup.players)) {
                        totalPlayerCount += answerGroup.players.length;
                    } else if (answerGroup.count && typeof answerGroup.count === 'number') {
                        totalPlayerCount += answerGroup.count;
                    } else if (answerGroup.totalResponses && typeof answerGroup.totalResponses === 'number') {
                        totalPlayerCount += answerGroup.totalResponses;
                    }
                });
                
                const isEmpty = totalPlayerCount === 0;
                bucketDiv.className = `answer-bucket correct-bucket${isEmpty ? ' empty' : ''}`;
                bucketDiv.id = bucketId; // align with updateAnswerBucketsSmoothly to avoid duplicates
                bucketDiv.dataset.bucketId = bucket.id;
                bucketDiv.innerHTML = `
                    <h4 onclick="toggleBucket(this)">
                        <span class="bucket-toggle collapsed">‚ñ∂</span>
                        ‚úÖ ${bucket.name}
                        <span class="answer-count-badge">${totalPlayerCount}</span>
                    </h4>
                    <div class="answer-items collapsed" data-bucket="${bucket.id}">
                        ${bucket.answers.map(group => {
                            const playerCount = group.players ? group.players.length : group.count || 1;
                            const playerNames = group.players ? group.players.join(', ') : '';
                            return createAnswerItemHTML(group.answer, playerCount, group.semanticConfidence, playerNames);
                        }).join('')}
                    </div>
                `;
                document.getElementById('correctAnswers').appendChild(bucketDiv);
            });
            
            // Populate uncategorized answers (non-matching)
            await populateUncategorizedAnswers(answersToRemove);
            
            // Update count badges
            updateCountBadges();
            
            // Setup drag and drop for all elements (rebind once)
            setupDragAndDrop();
            
                    // Restore saved grading state if available
        setTimeout(() => {
            console.log('üîÑ setTimeout triggered for state restoration after 100ms');
            console.log('üîÑ Current question:', currentGame?.currentQuestionIndex);
            console.log('üîÑ Skip restoration flag:', window.skipStateRestoration);
            
            const restored = restoreGradingState();
            if (restored) {
                // State was restored - clear any duplicates and skip repopulation
                console.log('üíæ State restored - cleaning up duplicates');
                removeDuplicateAnswers();
                window.skipPopulateUncategorized = true;
                setTimeout(() => {
                    window.skipPopulateUncategorized = false;
                }, 1000);
            } else {
                // No saved state - save the initial auto-categorized state
                console.log('üíæ No state restored - will save fresh state in 500ms');
                setTimeout(() => {
                    console.log('üíæ Saving fresh grading state');
                    saveGradingState();
                }, 500);
            }
        }, 100);
        }

        async function populateUncategorizedAnswers(answersToRemove = []) {
            // Check if we should skip this call due to a recent restore
            if (window.skipPopulateUncategorized) {
                return;
            }
            
            // If no answersToRemove provided, calculate them from current state
            if (answersToRemove.length === 0) {
                const questionData = currentGame.currentQuestionData;
                const correctAnswerList = questionData?.correct_answers || [];
                
                // Simple matching for uncategorized answers
                (currentGame.currentAnswerGroups || []).forEach(answerGroup => {
                    const matchingBucket = correctAnswerList.find(correctAnswer => {
                        const normalizedAnswer = normalizeAnswer(answerGroup.answer);
                        const normalizedCorrect = normalizeAnswer(correctAnswer);
                        return normalizedAnswer === normalizedCorrect;
                    });
                    
                    if (matchingBucket) {
                        answersToRemove.push(answerGroup.answer);
                    }
                });
            }
            
            // Build a set of players already placed in non-uncategorized buckets to preserve manual placements
            const placedPlayersLower = new Set();
            try {
                const nonUncatPlayerEls = Array.from(document.querySelectorAll('.answer-bucket:not(.uncategorized-bucket) .answer-players'));
                nonUncatPlayerEls.forEach(el => {
                    const names = (el.textContent || '').split(',').map(s => s.trim()).filter(Boolean);
                    names.forEach(n => placedPlayersLower.add(n.toLowerCase()));
                });
            } catch (_) {}

            // Populate uncategorized answers (non-matching), excluding players already placed elsewhere
            const uncategorizedAnswers = (currentGame.currentAnswerGroups || []).map(group => {
                const keepPlayers = (group.players || []).filter(p => !placedPlayersLower.has(String(p).toLowerCase()));
                if (keepPlayers.length === 0) return null;
                return { ...group, players: keepPlayers, count: keepPlayers.length };
            }).filter(group => group && !answersToRemove.includes(group.answer));
            
            // Calculate confidence scores for uncategorized answers
            const questionData = currentGame.currentQuestionData;
            const correctAnswerList = questionData?.correct_answers || [];
            
            uncategorizedAnswers.forEach(answerGroup => {
                if (!answerGroup.semanticConfidence) {
                    // Find the best matching correct answer for confidence calculation
                    let bestConfidence = 0;
                    let bestMatch = null;
                    
                    correctAnswerList.forEach(correctAnswer => {
                        const confidence = calculateSemanticConfidence(answerGroup.answer, correctAnswer);
                        if (confidence > bestConfidence) {
                            bestConfidence = confidence;
                            bestMatch = correctAnswer;
                        }
                    });
                    
                    // Set confidence data for uncategorized answers
                    answerGroup.semanticConfidence = bestConfidence;
                    answerGroup.semanticMatch = bestMatch;
                    
                    console.log(`üß† Calculated confidence for uncategorized "${answerGroup.answer}": ${bestConfidence}% ‚Üí "${bestMatch}"`);
                }
            });
            
            const uncategorizedContainer = document.getElementById('uncategorizedAnswers');
            
            if (uncategorizedContainer) {
                // Check if there are already items in the container (indicating a restore happened)
                const existingItems = uncategorizedContainer.children.length;
                
                if (existingItems > 0) {
                    return; // Skip repopulation - items already exist
                }
                
                uncategorizedContainer.innerHTML = '';
                
                uncategorizedAnswers.forEach((group, index) => {
                    const answerItem = createAnswerItem(group, index);
                    uncategorizedContainer.appendChild(answerItem);
                });
            }
            
            // Setup drag and drop after populating
            setupDragAndDrop();
            updateCountBadges();
        }

        function createAnswerItemHTML(answerText, playerCount, semanticConfidence, playerNames) {
            let confidenceDisplay = '';
            if (semanticConfidence !== undefined) {
                const confidenceColor = semanticConfidence >= 80 ? '#27ae60' : 
                                      semanticConfidence >= 50 ? '#f39c12' : '#e74c3c';
                confidenceDisplay = `
                    <div class="answer-confidence" style="color: ${confidenceColor}; font-size: 11px; margin-top: 3px;">
                        üß† ${semanticConfidence}%
                    </div>
                `;
            }
            
            return `
                <div class="answer-item" draggable="true" data-answer-text="${answerText}" data-player-names="${playerNames || ''}">
                    <div class="answer-text">"${answerText}" <span class="answer-count-badge">${playerCount}</span></div>
                    <div class="answer-players">${playerNames || ''}</div>
                    ${confidenceDisplay}
                </div>
            `;
        }

        function createAnswerItem(group, index) {
            const item = document.createElement('div');
            item.className = 'answer-item';
            item.draggable = true;
            item.dataset.answerIndex = index;
            item.dataset.answerText = group.answer;
            
            let confidenceDisplay = '';
            if (group.semanticConfidence !== undefined) {
                const confidenceColor = group.semanticConfidence >= 80 ? '#27ae60' : 
                                      group.semanticConfidence >= 50 ? '#f39c12' : '#e74c3c';
                confidenceDisplay = `
                    <div class="answer-confidence" style="color: ${confidenceColor}; font-size: 11px; margin-top: 3px;">
                        üß† ${group.semanticConfidence}%${group.semanticMatch ? ` ‚Üí "${group.semanticMatch}"` : ''}
                    </div>
                `;
            }
            
            item.innerHTML = `
                <div class="answer-text">"${group.answer}" <span class="answer-count-badge">${group.players ? group.players.length : group.count}</span></div>
                <div class="answer-players">${group.players ? group.players.join(', ') : ''}</div>
                ${confidenceDisplay}
            `;
            
            return item;
        }

        function setupDragAndDrop() {
            // Use event delegation instead of individual listeners to prevent memory leaks
            document.removeEventListener('dragstart', globalDragHandler);
            document.removeEventListener('dragend', globalDragHandler);
            document.removeEventListener('dragover', globalDragHandler);
            document.removeEventListener('dragenter', globalDragHandler);
            document.removeEventListener('dragleave', globalDragHandler);
            document.removeEventListener('drop', globalDragHandler);
            
            // Set up global event delegation
            document.addEventListener('dragstart', globalDragHandler);
            document.addEventListener('dragend', globalDragHandler);
            document.addEventListener('dragover', globalDragHandler);
            document.addEventListener('dragenter', globalDragHandler);
            document.addEventListener('dragleave', globalDragHandler);
            document.addEventListener('drop', globalDragHandler);
        }

        // Global drag handler using event delegation (prevents memory leaks)
        function globalDragHandler(e) {
            const answerItem = e.target.closest('.answer-item');
            const dropZone = e.target.closest('.answer-items');
            const bucket = e.target.closest('.answer-bucket');
            
            switch(e.type) {
                case 'dragstart':
                    if (answerItem) handleDragStart(e);
                    break;
                case 'dragend':
                    if (answerItem) handleDragEnd(e);
                    break;
                case 'dragover':
                    if (dropZone || bucket) handleDragOver(e);
                    break;
                case 'dragenter':
                    if (dropZone || bucket) handleDragEnter(e);
                    break;
                case 'dragleave':
                    if (dropZone || bucket) handleDragLeave(e);
                    break;
                case 'drop':
                    if (bucket) handleDropOnBucket(e);
                    else if (dropZone) handleDrop(e);
                    break;
            }
        }

        function handleDragStart(e) {
            console.log('üéØ Drag start:', e.target);
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedElement = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const target = e.target.closest('.answer-items') || e.target.closest('.answer-bucket');
            if (target) {
                target.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            const target = e.target.closest('.answer-items') || e.target.closest('.answer-bucket');
            if (target) {
                target.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            console.log('üéØ Drop event:', e.target);
            const dropZone = e.target.closest('.answer-items');
            console.log('üéØ Drop zone found:', dropZone);
            dropZone.classList.remove('drag-over');
            
            if (draggedElement && dropZone) {
                console.log('üéØ Moving element to drop zone');
                dropZone.appendChild(draggedElement);
                
                // Update confidence display for moved element
                updateConfidenceForMovedElement(draggedElement, dropZone);
                
                updateCountBadges();
                
                // Auto-save after drop
                autoSave();
            } else {
                console.log('üéØ Drop failed:', { draggedElement: !!draggedElement, dropZone: !!dropZone });
            }
        }

        function handleDropOnBucket(e) {
            e.preventDefault();
            console.log('üéØ Drop on bucket event:', e.target);
            const bucket = e.target.closest('.answer-bucket');
            const dropZone = bucket.querySelector('.answer-items');
            console.log('üéØ Bucket drop zone found:', dropZone);
            console.log('üéØ Dragged element:', draggedElement);
            console.log('üéØ Dragged element data-answer-text:', draggedElement?.dataset.answerText);
            
            // Remove drag-over class from any elements
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            
            if (draggedElement && dropZone) {
                console.log('üéØ Moving element to bucket drop zone');
                
                // Get bucket name for consolidation
                const bucketName = bucket.querySelector('h4')?.textContent?.replace(/[‚ñº‚ñ∂]\s*/, '').trim() || 'Unknown';
                const draggedAnswer = draggedElement.dataset.answerText;
                
                console.log(`üéØ Consolidating "${draggedAnswer}" into "${bucketName}" bucket`);
                
                // Add the dragged element first
                dropZone.appendChild(draggedElement);
                
                // Update confidence display for moved element
                updateConfidenceForMovedElement(draggedElement, dropZone);
                
                // Consolidate all answers in this bucket
                consolidateBucketAnswers(dropZone, bucketName);

                // If this is the Send Back bucket, request edits from players
                if (bucketName === '‚úèÔ∏è Send Back (Refine)') {
                    try {
                        let names = (draggedElement.dataset.playerNames || '').split(',').map(n => n.trim()).filter(Boolean);
                        const reason = prompt('Reason to send back (optional):', 'Please be more specific');
                        // Fallback: if no names were embedded on the chip, derive from current answer groups by text
                        if (!names || names.length === 0) {
                            try {
                                const draggedText = draggedElement?.dataset?.answerText || '';
                                const group = (currentGame?.currentAnswerGroups || []).find(g => (g.answer || '').toLowerCase().trim() === draggedText.toLowerCase().trim());
                                if (group && Array.isArray(group.players) && group.players.length > 0) {
                                    names = group.players.slice();
                                }
                            } catch (_) {}
                        }
                        // Locally remove these players from the corresponding answer group to prevent reappearance
                        try {
                            const draggedText = (draggedElement?.dataset?.answerText || '').toLowerCase().trim();
                            if (currentGame && Array.isArray(currentGame.currentAnswerGroups)) {
                                currentGame.currentAnswerGroups = currentGame.currentAnswerGroups.map(g => {
                                    if ((g.answer || '').toLowerCase().trim() !== draggedText) return g;
                                    const remaining = (g.players || []).filter(p => !names.includes(p));
                                    return { ...g, players: remaining, count: remaining.length };
                                }).filter(g => Array.isArray(g.players) ? g.players.length > 0 : (g.count || 0) > 0);
                            }
                        } catch (_) {}
                        if (!names || names.length === 0) {
                            console.warn('‚úèÔ∏è Could not resolve player names for send-back; no event emitted');
                            return;
                        }
                        console.log('‚úèÔ∏è Sending back for refinement:', { names, reason, gameCode: currentGame?.gameCode });
                        names.forEach(name => {
                            // Try to resolve socketId if helper exists; otherwise rely on server name resolution
                            let socketId;
                            try {
                                if (typeof getSocketIdByPlayerName === 'function') {
                                    socketId = getSocketIdByPlayerName(name);
                                }
                            } catch (_) {}
                            console.log('‚úèÔ∏è Emitting hostRequestEdit', { gameCode: currentGame?.gameCode, playerSocketId: socketId, playerName: name, reason });
                            socket.emit('hostRequestEdit', { gameCode: currentGame.gameCode, playerSocketId: socketId || undefined, playerName: name, reason });
                        });
                    } catch (err) { console.warn('Failed to send back request', err); }
                }
                
                updateCountBadges();
                
                // Auto-save after drop
                console.log('üéØ Triggering auto-save after drop');
                autoSave();
            } else {
                console.log('üéØ Bucket drop failed:', { draggedElement: !!draggedElement, dropZone: !!dropZone });
            }
        }

        function consolidateBucketAnswers(dropZone, bucketName) {
            console.log(`üéØ Consolidating answers in bucket: "${bucketName}"`);
            
            // Get all answer items in this bucket
            const answerItems = Array.from(dropZone.querySelectorAll('.answer-item'));
            console.log(`üéØ Found ${answerItems.length} answer items to consolidate`);
            
            if (answerItems.length <= 1) {
                console.log('üéØ Only one answer item, no consolidation needed');
                return;
            }
            
            // Calculate total player count
            let totalPlayers = 0;
            const allPlayerNames = [];
            const individualAnswers = [];
            
            answerItems.forEach(item => {
                const playerCount = parseInt(item.querySelector('.answer-count-badge')?.textContent || '1');
                const answerText = item.dataset.answerText;
                totalPlayers += playerCount;
                
                // Collect player names if available
                const playerNames = item.querySelector('.answer-players')?.textContent;
                if (playerNames) {
                    allPlayerNames.push(playerNames);
                }
                
                // Store individual answer for display
                individualAnswers.push({
                    text: answerText,
                    count: playerCount,
                    players: playerNames
                });
            });
            
            console.log(`üéØ Total players across all answers: ${totalPlayers}`);
            console.log(`üéØ Individual answers:`, individualAnswers);
            
            // Clear the drop zone
            dropZone.innerHTML = '';
            
            // Create individual answer items
            individualAnswers.forEach(answer => {
                const answerItem = document.createElement('div');
                answerItem.className = 'answer-item';
                answerItem.draggable = true;
                answerItem.dataset.answerText = answer.text;
                answerItem.dataset.playerNames = answer.players || '';
                
                // Style for individual answers within bucket
                answerItem.style.cssText = `
                    background: rgba(46, 204, 113, 0.1);
                    border: 1px solid rgba(46, 204, 113, 0.3);
                    margin: 4px 0;
                    padding: 6px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                `;
                
                answerItem.innerHTML = `
                    <div class="answer-text">"${answer.text}" <span class="answer-count-badge">${answer.count}</span></div>
                    <div class="answer-players" style="font-size: 10px; color: #666;">${answer.players || ''}</div>
                `;
                
                dropZone.appendChild(answerItem);
            });
            
            console.log(`üéØ Created bucket header: "${bucketName}" with ${totalPlayers} total players`);
            console.log(`üéØ Added ${individualAnswers.length} individual answer items`);
        }

        function showGradingConfirmation(categorization) {
            const totalCorrect = categorization.correctAnswerBuckets.reduce((sum, bucket) => sum + bucket.answers.length, 0);
            const totalWrong = categorization.wrong.length;
            const totalUncategorized = categorization.uncategorized.length;
            const totalAnswers = totalCorrect + totalWrong + totalUncategorized;
            
            // Create summary text
            let summaryText = `Grading Complete!\n\n`;
            summaryText += `üìä Summary:\n`;
            summaryText += `‚úÖ Correct: ${totalCorrect}\n`;
            summaryText += `‚ùå Wrong: ${totalWrong}\n`;
            summaryText += `üì¶ Uncategorized: ${totalUncategorized}\n`;
            summaryText += `üìã Total: ${totalAnswers}\n\n`;
            
            // Add details for correct answers
            if (totalCorrect > 0) {
                summaryText += `‚úÖ Correct Answers:\n`;
                // Sort buckets alphabetically before processing
                categorization.correctAnswerBuckets.sort((a, b) => {
                    const nameA = a.name || a.id || '';
                    const nameB = b.name || b.id || '';
                    return nameA.localeCompare(nameB);
                });
                categorization.correctAnswerBuckets.forEach(bucket => {
                    if (bucket.answers.length > 0) {
                        // Get bucket name from DOM
                        const bucketElement = document.querySelector(`[data-bucket="${bucket.id}"]`)?.closest('.answer-bucket');
                        const bucketName = bucketElement?.querySelector('h4')?.textContent?.replace(/[‚ñº‚ñ∂]\s*/, '').trim() || bucket.id;
                        summaryText += `  ${bucketName}: ${bucket.answers.map(a => `"${a.answer}"`).join(', ')}\n`;
                    }
                });
                summaryText += `\n`;
            }
            
            // Add details for wrong answers
            if (totalWrong > 0) {
                summaryText += `‚ùå Wrong Answers:\n`;
                summaryText += `  ${categorization.wrong.map(a => `"${a.answer}"`).join(', ')}\n\n`;
            }
            
            // Add details for uncategorized answers
            if (totalUncategorized > 0) {
                summaryText += `üì¶ Uncategorized Answers:\n`;
                summaryText += `  ${categorization.uncategorized.map(a => `"${a.answer}"`).join(', ')}\n\n`;
            }
            
            summaryText += `Click OK to continue to scoring phase.`;
            
            // Show the confirmation
            // alert(summaryText); // Removed alert box
        }

        function applyCategorization() {
            if (!currentGame) return;
            
            // Collect categorization data
            const categorization = {
                gameCode: currentGame.gameCode,
                correctAnswerBuckets: [],
                wrong: [],
                uncategorized: []
            };
            
            // Get correct answer buckets
            document.querySelectorAll('#correctAnswers .answer-bucket').forEach(bucket => {
                const bucketId = bucket.querySelector('.answer-items').dataset.bucket;
                const answers = Array.from(bucket.querySelectorAll('.answer-item')).map(item => ({
                    answer: item.dataset.answerText,
                    index: parseInt(item.dataset.answerIndex)
                }));
                
                categorization.correctAnswerBuckets.push({
                    id: bucketId,
                    answers: answers
                });
            });
            
            // Get wrong answers
            const wrongAnswers = Array.from(document.querySelectorAll('#wrongAnswers .answer-item')).map(item => ({
                answer: item.dataset.answerText,
                index: parseInt(item.dataset.answerIndex)
            }));
            categorization.wrong = wrongAnswers;
            
            // Get uncategorized answers
            const uncategorizedAnswers = Array.from(document.querySelectorAll('#uncategorizedAnswers .answer-item')).map(item => ({
                answer: item.dataset.answerText,
                index: parseInt(item.dataset.answerIndex)
            }));
            categorization.uncategorized = uncategorizedAnswers;
            
            console.log('Submitting categorization:', categorization);
            
            // Show confirmation dialog with results
            showGradingConfirmation(categorization);
            
            // Send categorization to server
            socket.emit('completeGrading', {
                gameCode: currentGame.gameCode,
                categorizedAnswers: categorization
            });

            // Optimistically close modal and signal completion in UI
            try {
                showTemporaryMessage('‚úÖ Grading submitted. Waiting for results‚Ä¶', 'success');
            } catch (_) {}
            try { window.close(); } catch (_) {}
        }

        function backToGames() {
            currentGame = null;
            document.getElementById('gradingInterface').style.display = 'none';
            document.getElementById('gameSelection').style.display = 'block';
            updateGameList();
            
            // Close this grading interface window and focus back on main host window
            if (window.opener) {
                // If opened as popup, close this window and focus opener
                window.opener.focus();
                window.close();
            } else {
                // If opened in same tab, navigate to host
                window.location.href = '/host';
            }
        }

        function nextQuestion() {
            if (!currentGame) {
                console.error('‚ùå No current game to proceed to next question');
                return;
            }

            console.log('‚ñ∂Ô∏è Proceeding to next question for game:', currentGame.gameCode);
            
            // Check if this is the last question in the round/game
            const isLastQuestion = currentGame.currentQuestion >= currentGame.questionsPerRound;
            
            if (isLastQuestion) {
                console.log('üèÅ This was the last question in the game');
                showTemporaryMessage('üèÅ Game completed! Final scores will be displayed.', 'success');
            }
            
            // Emit nextQuestion event to server
            socket.emit('nextQuestion', {
                gameCode: currentGame.gameCode
            });

            // Hide the Next Question button after clicking
            document.getElementById('nextQuestionBtn').style.display = 'none';
        }

        function normalizeAnswer(answer) {
            return answer
                .toLowerCase()                    // Convert to lowercase
                .trim()                          // Remove leading/trailing spaces
                .replace(/\s+/g, ' ')            // Replace multiple spaces with single space
                .replace(/[^\w\s]/g, '')         // Remove all punctuation except spaces
                .trim();                         // Trim again after punctuation removal
        }
        
        // Calculate semantic confidence between two answers
        function calculateSemanticConfidence(answerText, correctAnswer) {
            const normalizedAnswer = normalizeAnswer(answerText);
            const normalizedCorrect = normalizeAnswer(correctAnswer);
            
            // Exact match gets 100% confidence
            if (normalizedAnswer === normalizedCorrect) {
                return 100;
            }
            
            // Check for high-confidence substring matches (e.g., "billy goat" contains "goat")
            if (normalizedAnswer.includes(normalizedCorrect)) {
                // If the correct answer is contained in the response, high confidence
                return 95; // Very high confidence for containing the exact animal name
            }
            
            if (normalizedCorrect.includes(normalizedAnswer)) {
                // If the response is contained in the correct answer
                return 90;
            }
            
            // Calculate similarity using simple string comparison
            let similarity = 0;
            const maxLength = Math.max(normalizedAnswer.length, normalizedCorrect.length);
            
            if (maxLength === 0) return 0;
            
            // Calculate character-by-character similarity for fuzzy matches
            let matches = 0;
            const minLength = Math.min(normalizedAnswer.length, normalizedCorrect.length);
            
            for (let i = 0; i < minLength; i++) {
                if (normalizedAnswer[i] === normalizedCorrect[i]) {
                    matches++;
                }
            }
            
            similarity = matches / maxLength;
            
            // Convert to percentage and round
            return Math.round(similarity * 100);
        }

        async function getSemanticMatches(question, correctAnswers, responses) {
            try {
                // Use the server's integrated semantic matcher
                const response = await fetch('/api/semantic-match', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        question: question, 
                        correct_answers: correctAnswers, 
                        responses: responses 
                    })
                });
                if (!response.ok) { 
                    throw new Error(`HTTP error! status: ${response.status}`); 
                }
                const data = await response.json();
                return data.results;
            } catch (error) {
                console.error('Error calling semantic matcher:', error);
                throw error;
            }
        }

        function updateCountBadges() {
            // Update wrong answers count
            const wrongAnswersCount = document.querySelectorAll('#wrongAnswers .answer-item').length;
            document.getElementById('wrongAnswersCount').textContent = wrongAnswersCount;
            
            // Update uncategorized answers count
            const uncategorizedAnswersCount = document.querySelectorAll('#uncategorizedAnswers .answer-item').length;
            document.getElementById('uncategorizedAnswersCount').textContent = uncategorizedAnswersCount;
            
            // Update correct answer bucket counts by unique players across all items
            document.querySelectorAll('#correctAnswers .answer-bucket').forEach(bucket => {
                const countBadge = bucket.querySelector('.answer-count-badge');
                if (countBadge) {
                    // Calculate total unique player count for this bucket
                    const uniquePlayers = new Set();
                    const playerEls = bucket.querySelectorAll('.answer-players');
                    playerEls.forEach(el => {
                        const names = (el.textContent || '').split(',').map(s=>s.trim()).filter(Boolean);
                        names.forEach(n => uniquePlayers.add(n));
                    });
                    countBadge.textContent = uniquePlayers.size;
                }
            });
        }

        function toggleBucket(headerElement) {
            const bucket = headerElement.parentElement;
            const answerItems = bucket.querySelector('.answer-items');
            const toggle = headerElement.querySelector('.bucket-toggle');
            
            if (answerItems.classList.contains('collapsed')) {
                answerItems.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
            } else {
                answerItems.classList.add('collapsed');
                toggle.classList.add('collapsed');
            }
        }

        // Event listeners
                    document.getElementById('applyCategorizationBtn').addEventListener('click', applyCategorization);
            document.getElementById('nextQuestionBtn').addEventListener('click', nextQuestion);

        // Update confidence display for moved elements
        function updateConfidenceForMovedElement(draggedElement, dropZone) {
            const answerText = draggedElement.dataset.answerText;
            if (!answerText) return;
            
            // Determine if this is a correct answer bucket or uncategorized
            const bucketId = dropZone.dataset.bucket;
            const isCorrectBucket = bucketId && bucketId.startsWith('correct_');
            
            if (isCorrectBucket) {
                // If moved to a correct answer bucket, set confidence to 100%
                const confidenceDisplay = draggedElement.querySelector('.answer-confidence');
                if (confidenceDisplay) {
                    confidenceDisplay.innerHTML = `üß† 100% ‚Üí "${answerText}"`;
                    confidenceDisplay.style.color = '#27ae60';
                } else {
                    // Create confidence display if it doesn't exist
                    const newConfidenceDisplay = document.createElement('div');
                    newConfidenceDisplay.className = 'answer-confidence';
                    newConfidenceDisplay.style.cssText = 'color: #27ae60; font-size: 11px; margin-top: 3px;';
                    newConfidenceDisplay.innerHTML = `üß† 100% ‚Üí "${answerText}"`;
                    draggedElement.appendChild(newConfidenceDisplay);
                }
            } else {
                // If moved to uncategorized, calculate confidence against all correct answers
                const questionData = currentGame.currentQuestionData;
                const correctAnswerList = questionData?.correct_answers || [];
                
                let bestConfidence = 0;
                let bestMatch = null;
                
                correctAnswerList.forEach(correctAnswer => {
                    const confidence = calculateSemanticConfidence(answerText, correctAnswer);
                    if (confidence > bestConfidence) {
                        bestConfidence = confidence;
                        bestMatch = correctAnswer;
                    }
                });
                
                // Update or create confidence display
                let confidenceDisplay = draggedElement.querySelector('.answer-confidence');
                if (!confidenceDisplay) {
                    confidenceDisplay = document.createElement('div');
                    confidenceDisplay.className = 'answer-confidence';
                    confidenceDisplay.style.cssText = 'font-size: 11px; margin-top: 3px;';
                    draggedElement.appendChild(confidenceDisplay);
                }
                
                const confidenceColor = bestConfidence >= 80 ? '#27ae60' : 
                                      bestConfidence >= 50 ? '#f39c12' : '#e74c3c';
                confidenceDisplay.style.color = confidenceColor;
                confidenceDisplay.innerHTML = `üß† ${bestConfidence}%${bestMatch ? ` ‚Üí "${bestMatch}"` : ''}`;
                
                console.log(`üß† Updated confidence for moved "${answerText}": ${bestConfidence}% ‚Üí "${bestMatch}"`);
            }
        }

        // ===== GRADING STATE PERSISTENCE =====
        
        // Save current grading state to localStorage
        function saveGradingState() {
            if (!currentGame || !currentGame.currentQuestionData) return;
            
            const state = {
                gameCode: currentGame.gameCode,
                questionIndex: currentGame.currentQuestionIndex,
                timestamp: Date.now(),
                buckets: {}
            };
            
            // Save state for each bucket
            const allBuckets = document.querySelectorAll('.answer-bucket');
            
            allBuckets.forEach(bucket => {
                const bucketId = bucket.dataset.bucketId;
                if (!bucketId) return;
                
                const answerItems = bucket.querySelectorAll('.answer-item');
                const items = [];
                
                answerItems.forEach(item => {
                    const answerText = item.dataset.answerText;
                    const playerCount = parseInt(item.querySelector('.answer-count-badge')?.textContent || '1');
                    const confidence = item.querySelector('.answer-confidence')?.textContent || '';
                    const playerNames = item.dataset.playerNames || '';
                    
                    items.push({
                        answerText: answerText,
                        playerCount: playerCount,
                        confidence: confidence,
                        playerNames: playerNames
                    });
                });
                
                state.buckets[bucketId] = items;
            });
            
            // Save state for uncategorized and wrong answer containers
            const uncategorizedContainer = document.getElementById('uncategorizedAnswers');
            if (uncategorizedContainer) {
                const uncategorizedItems = uncategorizedContainer.querySelectorAll('.answer-item');
                const items = [];
                
                uncategorizedItems.forEach(item => {
                    items.push({
                        answerText: item.dataset.answerText,
                        playerCount: parseInt(item.querySelector('.answer-count-badge')?.textContent || '1'),
                        confidence: item.querySelector('.answer-confidence')?.textContent || '',
                        playerNames: item.dataset.playerNames || ''
                    });
                });
                
                state.buckets['uncategorized'] = items;
            }
            
            const wrongContainer = document.getElementById('wrongAnswers');
            if (wrongContainer) {
                const wrongItems = wrongContainer.querySelectorAll('.answer-item');
                const items = [];
                
                wrongItems.forEach(item => {
                    items.push({
                        answerText: item.dataset.answerText,
                        playerCount: parseInt(item.querySelector('.answer-count-badge')?.textContent || '1'),
                        confidence: item.querySelector('.answer-confidence')?.textContent || '',
                        playerNames: item.dataset.playerNames || ''
                    });
                });
                
                state.buckets['wrong'] = items;
            }
            
            const stateKey = `grading_state_${currentGame.gameCode}_${currentGame.currentQuestionIndex}`;
            localStorage.setItem(stateKey, JSON.stringify(state));
            
            // Show save indicator
            showSaveIndicator();
        }

        // Clear grading state for previous questions to prevent wrong answers from persisting
        function clearPreviousGradingStates() {
            if (!currentGame) return;
            
            console.log('üßπ Clearing previous grading states for game:', currentGame.gameCode);
            
            // Get all localStorage keys that match our grading state pattern
            const gradingStatePrefix = `grading_state_${currentGame.gameCode}_`;
            const keysToRemove = [];
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(gradingStatePrefix)) {
                    // Extract the question index from the key
                    const questionIndex = parseInt(key.replace(gradingStatePrefix, ''));
                    
                    // Remove states from previous questions (not current)
                    if (!isNaN(questionIndex) && questionIndex !== currentGame.currentQuestionIndex) {
                        keysToRemove.push(key);
                        console.log(`üóëÔ∏è Marking for removal: ${key} (Q${questionIndex} != current Q${currentGame.currentQuestionIndex})`);
                    }
                }
            }
            
            // Remove the identified keys
            keysToRemove.forEach(key => {
                localStorage.removeItem(key);
                console.log(`üóëÔ∏è Removed old grading state: ${key}`);
            });
            
            console.log(`üßπ Cleared ${keysToRemove.length} previous grading states`);
            
            // Do NOT clear current question's state; we want to preserve manual placements across clarify/reloads
            // Also avoid blocking restoration so the UI can rebuild from saved state quickly
        }
        
        // Restore grading state from localStorage
        function restoreGradingState() {
            if (!currentGame || !currentGame.currentQuestionData) return false;
            
            // Check if state restoration should be skipped (after clearing previous states)
            if (window.skipStateRestoration) {
                console.log('‚è≠Ô∏è Skipping state restoration due to fresh question load');
                return false;
            }
            
            const stateKey = `grading_state_${currentGame.gameCode}_${currentGame.currentQuestionIndex}`;
            const savedState = localStorage.getItem(stateKey);
            
            console.log('üíæ Attempting to restore state for key:', stateKey);
            console.log('üíæ Found saved state:', !!savedState);
            
            if (!savedState) {
                console.log('üíæ No saved state found for current question');
                return false;
            }
            
            try {
                const state = JSON.parse(savedState);
                
                // Check if state is still valid (same game and question)
                if (state.gameCode !== currentGame.gameCode || 
                    state.questionIndex !== currentGame.currentQuestionIndex) {
                    localStorage.removeItem(stateKey);
                    return false;
                }
                
                // Clear ALL buckets first to prevent duplicates
                document.querySelectorAll('.answer-items').forEach(container => {
                    container.innerHTML = '';
                });
                
                // Apply saved state
                let restoredAny = false;
                Object.keys(state.buckets).forEach(bucketId => {
                    let bucket, dropZone;
                    
                    // Handle different bucket types
                    if (bucketId === 'uncategorized') {
                        dropZone = document.getElementById('uncategorizedAnswers');
                    } else if (bucketId === 'wrong') {
                        dropZone = document.getElementById('wrongAnswers');
                    } else {
                        bucket = document.querySelector(`[data-bucket-id="${bucketId}"]`);
                        dropZone = bucket?.querySelector('.answer-items');
                    }
                    
                    if (!dropZone) return;
                    
                    // Restore items if there are any
                    if (state.buckets[bucketId].length > 0) {
                        restoredAny = true;
                        
                        // Add saved items
                        state.buckets[bucketId].forEach(item => {
                        // Extract confidence percentage from the saved confidence text
                        let confidence = 0;
                        if (item.confidence) {
                            const match = item.confidence.match(/üß† (\d+)%/);
                            if (match) {
                                confidence = parseInt(match[1]);
                            }
                        }
                        
                        const answerItemHTML = createAnswerItemHTML(
                            item.answerText,
                            item.playerCount,
                            confidence,
                            item.playerNames
                        );
                        // Convert HTML string to DOM element
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = answerItemHTML;
                        const answerItem = tempDiv.firstElementChild;
                        dropZone.appendChild(answerItem);
                    });
                    }
                });
                
                // Re-setup drag and drop
                setupDragAndDrop();
                updateCountBadges();
                
                console.log('‚úÖ Grading state restored successfully');
                showRestoreIndicator();
                return restoredAny;
                
            } catch (error) {
                console.error('‚ùå Error restoring grading state:', error);
                localStorage.removeItem(stateKey);
                return false;
            }
        }
        
        // Show save indicator
        function showSaveIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'save-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #27ae60;
                color: white;
                padding: 10px 15px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 1000;
                animation: slideInRight 0.3s ease;
            `;
            indicator.textContent = 'üíæ State Saved';
            
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 300);
            }, 2000);
        }
        
        // Show restore indicator
        function showRestoreIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'restore-indicator';
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #007bff;
                color: white;
                padding: 10px 15px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 1000;
                animation: slideInRight 0.3s ease;
            `;
            indicator.textContent = 'üìÇ State Restored';
            
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 300);
            }, 2000);
        }
        
        // Add CSS animations for indicators
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Remove duplicate answers that might exist after state restoration
        function removeDuplicateAnswers() {
            const seenAnswers = new Set();
            const allAnswerItems = document.querySelectorAll('.answer-item');
            
            allAnswerItems.forEach(item => {
                const answerText = item.dataset.answerText;
                if (seenAnswers.has(answerText)) {
                    // This is a duplicate - remove it
                    console.log(`üßπ Removing duplicate answer: "${answerText}"`);
                    item.remove();
                } else {
                    seenAnswers.add(answerText);
                }
            });
            
            // Update counts after cleanup
            updateCountBadges();
        }

        // Auto-save on drag and drop
        function autoSave() {
            setTimeout(() => {
                try {
                    saveGradingState();
                } catch (error) {
                    console.error('Auto-save failed:', error);
                }
            }, 100); // Small delay to ensure DOM is updated
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeConnection();
            
            // Auto-save on page unload
            window.addEventListener('beforeunload', () => {
                saveGradingState();
            });
            
            // Auto-save on page hide (for mobile browsers and some popup scenarios)
            window.addEventListener('pagehide', () => {
                saveGradingState();
            });
            
            // Auto-save on visibility change (when tab becomes hidden)
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    saveGradingState();
                }
            });
            
            // Auto-save every 10 seconds as backup (more frequent to catch changes)
            setTimeout(() => {
                setInterval(() => {
                    if (currentGame && currentGame.currentQuestionData) {
                        try {
                            saveGradingState();
                        } catch (error) {
                            console.error('Periodic auto-save failed:', error);
                        }
                    }
                }, 10000);
            }, 10000);
        });

        // Re-sync function to refresh game data
        async function resyncGameData() {
            console.log('üîÑ Re-syncing game data...');
            
            if (!currentGame || !currentGame.gameCode) {
                console.error('‚ùå No current game to re-sync');
                showToast('No active game to re-sync', 'error');
                return;
            }

            try {
                // Show loading state
                const resyncBtn = document.getElementById('resyncBtn');
                const originalText = resyncBtn.textContent;
                resyncBtn.textContent = 'üîÑ Syncing...';
                resyncBtn.disabled = true;

                // Re-request game data from server
                socket.emit('getGameState', currentGame.gameCode);
                
                // Also try to get active games as a fallback
                socket.emit('getActiveGames');
                
                console.log('üîó Emitting getActiveGames as fallback');
                
                // Wait a bit for server response
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Re-populate the interface
                if (currentGame && currentGame.currentQuestionData) {
                    await populateGradingInterface();
                    showToast('Game data re-synced successfully!', 'success');
                } else {
                    showToast('Failed to re-sync game data', 'error');
                }

            } catch (error) {
                console.error('‚ùå Re-sync failed:', error);
                showToast('Re-sync failed: ' + error.message, 'error');
            } finally {
                // Restore button state
                const resyncBtn = document.getElementById('resyncBtn');
                resyncBtn.textContent = originalText;
                resyncBtn.disabled = false;
            }
        }

        // Enhanced fallback logic for missing data
        function applyFallbackLogic() {
            console.log('üõ°Ô∏è Applying fallback logic for missing data...');
            
            if (!currentGame) {
                console.warn('‚ö†Ô∏è No current game, cannot apply fallbacks');
                return;
            }

            // Fallback 1: If currentAnswerGroups is missing, try to reconstruct from other sources
            if (!currentGame.currentAnswerGroups || currentGame.currentAnswerGroups.length === 0) {
                console.log('üîÑ Fallback: Reconstructing answer groups...');
                
                // Try to get from localStorage as last resort
                const savedState = localStorage.getItem(`gradingState_${currentGame.gameCode}_${currentGame.currentQuestionIndex}`);
                if (savedState) {
                    try {
                        const parsed = JSON.parse(savedState);
                        if (parsed.answerGroups && parsed.answerGroups.length > 0) {
                            currentGame.currentAnswerGroups = parsed.answerGroups;
                            console.log('‚úÖ Restored answer groups from localStorage');
                        }
                    } catch (e) {
                        console.error('‚ùå Failed to parse saved state:', e);
                    }
                }
            }

            // Fallback 2: If question data is missing, try to get from URL or localStorage
            if (!currentGame.currentQuestionData) {
                console.log('üîÑ Fallback: Reconstructing question data...');
                
                const urlParams = new URLSearchParams(window.location.search);
                const questionIndex = urlParams.get('question') || currentGame.currentQuestionIndex || 0;
                
                // Try to get from localStorage
                const savedState = localStorage.getItem(`gradingState_${currentGame.gameCode}_${questionIndex}`);
                if (savedState) {
                    try {
                        const parsed = JSON.parse(savedState);
                        if (parsed.questionData) {
                            currentGame.currentQuestionData = parsed.questionData;
                            console.log('‚úÖ Restored question data from localStorage');
                        }
                    } catch (e) {
                        console.error('‚ùå Failed to parse saved question data:', e);
                    }
                }
            }

            // Fallback 3: If game state is completely missing, try to reconnect
            if (!currentGame.gameCode) {
                console.log('üîÑ Fallback: Attempting to reconnect...');
                socket.emit('getActiveGames');
            }
        }

        // Enhanced error handling for missing data
        function handleMissingData() {
            console.log('üîç Checking for missing data...');
            
            const hasAnswerGroups = currentGame && currentGame.currentAnswerGroups && currentGame.currentAnswerGroups.length > 0;
            const hasQuestionData = currentGame && currentGame.currentQuestionData;
            
            if (!hasAnswerGroups || !hasQuestionData) {
                console.warn('‚ö†Ô∏è Missing critical data, applying fallbacks...');
                applyFallbackLogic();
                
                // Show user-friendly message
                const message = !hasAnswerGroups && !hasQuestionData ? 
                    'Missing game data. Click Re-sync to refresh.' :
                    !hasAnswerGroups ? 'Missing answer data. Click Re-sync to refresh.' :
                    'Missing question data. Click Re-sync to refresh.';
                
                showToast(message, 'warning');
            }
        }

        // Enhanced populateGradingInterface with fallback support
        const originalPopulateGradingInterface = populateGradingInterface;
        populateGradingInterface = async function() {
            try {
                // Check for missing data before proceeding
                handleMissingData();
                
                // Call original function
                await originalPopulateGradingInterface();
                
            } catch (error) {
                console.error('‚ùå populateGradingInterface failed:', error);
                
                // Apply fallback logic
                applyFallbackLogic();
                
                // Try again with fallback data
                try {
                    await originalPopulateGradingInterface();
                } catch (fallbackError) {
                    console.error('‚ùå Even fallback failed:', fallbackError);
                    showToast('Failed to load grading interface. Please re-sync.', 'error');
                }
            }
        };
    </script>
</body>
</html> 