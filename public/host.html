<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEGASheep - Host Console</title>
    <link rel="stylesheet" href="styles.css">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* Host Console Specific Styles */
        body {
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #000033 100%);
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .host-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            overflow-y: auto;
        }

        /* Game Created Successfully Section */
        .game-created-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #007bff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 123, 255, 0.2);
            padding: 15px 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .game-created-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }

        .game-created-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-created-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .game-created-header h2 {
            color: #ffffff;
            margin: 0;
            font-size: 1.4em;
        }

        .game-code-display {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-code {
            font-size: 2.8em;
            font-weight: bold;
            color: #007bff;
            text-shadow: 2px 2px 4px rgba(0, 123, 255, 0.3);
            letter-spacing: 4px;
        }

        .game-code-label {
            color: #cccccc;
            font-size: 13px;
            white-space: nowrap;
        }

        .copy-btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
            font-weight: bold;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4);
        }

        .quick-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            flex-wrap: wrap;
        }

        .action-btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4);
        }

        /* Game Lobby Section */
        .game-lobby-section {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .lobby-icon {
            font-size: 2em;
        }

        .lobby-content h3 {
            color: white;
            margin: 0 0 5px 0;
            font-size: 1.5em;
        }

        .lobby-content p {
            color: rgba(255, 255, 255, 0.8);
            margin: 0;
            font-size: 16px;
        }

        /* Main Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        /* Right Column: Host Controls + Game Settings */
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }





        .dashboard-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #007bff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 123, 255, 0.2);
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(0, 123, 255, 0.3);
        }

        .panel-header h3 {
            color: #ffffff;
            margin: 0;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Players Panel */
        .player-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .player-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .player-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .player-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #007bff, #0056b3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 14px;
        }

        .player-details {
            display: flex;
            flex-direction: column;
        }

        .player-name {
            font-weight: bold;
            color: #ffffff;
            font-size: 12px;
        }

        .player-type {
            color: #cccccc;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .player-score {
            color: #27ae60;
            font-weight: bold;
            font-size: 12px;
        }

        /* Player Response Display */
        .player-response {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 123, 255, 0.1);
            border-radius: 6px;
            border-left: 3px solid #007bff;
        }

        .response-label {
            color: #cccccc;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
        }

        .response-text {
            color: #ffffff;
            font-style: italic;
        }
        
        .response-points {
            color: #28a745;
            font-weight: bold;
            font-size: 12px;
            margin-left: 8px;
        }

        .response-status {
            color: #ffc107;
            font-size: 12px;
        }

        .response-status.waiting {
            color: #6c757d;
        }
            font-size: 16px;
            font-style: italic;
            background: rgba(0, 123, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            border-left: 3px solid #007bff;
        }

        /* Scoring Panel */
        .scoring-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #28a745;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(40, 167, 69, 0.2);
            padding: 25px;
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
        }

        .scoring-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(40, 167, 69, 0.3);
        }

        .scoring-header h3 {
            color: #ffffff;
            margin: 0;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .scoring-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .scoring-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .scoring-section h4 {
            color: #ffffff;
            margin: 0 0 15px 0;
            font-size: 1.2em;
        }

        .answer-group {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .answer-text {
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 5px;
        }

        .answer-players {
            color: #cccccc;
            font-size: 12px;
        }

        .answer-points {
            color: #28a745;
            font-weight: bold;
            font-size: 14px;
            margin-top: 5px;
        }

        /* Host Controls Panel */
        .host-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .control-btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4);
        }

        .control-btn.success {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .control-btn.warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
            color: #000;
        }

        .control-btn.secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
        }

        /* Game Settings Panel */
        .game-settings {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #007bff;
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0, 123, 255, 0.2);
            padding: 10px;
            backdrop-filter: blur(10px);
            min-height: 220px;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .setting-group {
            margin-bottom: 8px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 3px;
            color: #ffffff;
            font-weight: bold;
            font-size: 11px;
        }

        .setting-group select,
        .setting-group input {
            width: 100%;
            padding: 6px;
            border: 1px solid rgba(0, 123, 255, 0.3);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #ffffff;
            font-size: 12px;
        }

        .setting-group select:focus,
        .setting-group input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }

        .setting-description {
            color: #cccccc;
            font-size: 9px;
            margin-top: 2px;
        }

        /* Connection Status */
        .connection-status {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #007bff;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            color: #ffffff;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .status-disconnected {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        /* No Game State */
        .no-game-state {
            text-align: center;
            padding: 50px;
            color: #cccccc;
            font-size: 18px;
        }

        .create-game-form {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #007bff;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            max-width: 400px;
            margin: 0 auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #ffffff;
            font-weight: bold;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(0, 123, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            color: #ffffff;
            font-size: 16px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #007bff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 123, 255, 0.3);
            margin: 2% auto;
            padding: 0;
            width: 90%;
            max-width: 1200px;
            height: 90%;
            max-height: 800px;
            position: relative;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .modal-content.fullscreen {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            margin: 0;
            border-radius: 0;
        }

        /* Default fullscreen for grading modal */
        #gradingSingleModalContent {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            margin: 0;
            border-radius: 0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid rgba(0, 123, 255, 0.3);
            background: linear-gradient(135deg, #007bff, #0056b3);
            border-radius: 18px 18px 0 0;
        }

        .modal-header h2 {
            color: white;
            margin: 0;
            font-size: 1.5em;
        }

        .close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close:hover {
            color: #ff6b6b;
            transform: scale(1.1);
        }

        .modal-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.4);
        }

        .control-btn.small {
            padding: 6px 10px;
            font-size: 11px;
        }

        .modal-body {
            padding: 0;
            height: calc(100% - 80px);
            overflow: hidden;
        }

        .modal-body iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0 0 18px 18px;
        }

        .modal-content.fullscreen .modal-body iframe {
            border-radius: 0;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .right-column {
                flex-direction: column;
            }
            
            .host-controls {
                grid-template-columns: 1fr;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
            
            .quick-actions {
                flex-direction: column;
                align-items: center;
            }

            .modal-content {
                width: 95%;
                height: 95%;
                margin: 2.5% auto;
            }
        }
    </style>
</head>
<body>
    <div class="host-container">
        <!-- Connection Status -->
        <div class="connection-status">
            <span class="status-indicator status-disconnected" id="connectionIndicator"></span>
            <span id="connectionStatus">Connecting to server...</span>
        </div>

        <!-- No Game State -->
        <div id="noGameState" class="no-game-state">
            <h2>üêë MEGASheep Host Console</h2>
            <p>Create a new game to get started</p>
            <div class="create-game-form">
                <button id="createGameBtn" class="control-btn">Create New Game</button>
            </div>
        </div>

        <!-- Active Game State -->
        <div id="activeGameState" style="display: none;">
            <!-- Game Created Successfully Section -->
            <div class="game-created-section">
                <div class="game-created-content">
                    <div class="game-created-left">
                        <div class="game-created-header">
                            <span style="font-size: 1.2em;">‚è∞</span>
                            <h2>Game Created Successfully!</h2>
                        </div>
                        <div class="game-code-display">
                            <div class="game-code-label">Share this code:</div>
                            <div class="game-code" id="gameCodeDisplay">----</div>
                            <button class="copy-btn" onclick="copyGameCode()">Copy Code</button>
                        </div>
                    </div>
                    <div class="quick-actions">
                        <a href="/" target="_blank" class="action-btn">üë§ Player Join Page</a>
                        <a href="/display" target="_blank" class="action-btn">üì∫ Display Screen</a>
                        <a href="/grading" target="_blank" class="action-btn">üìù Grading Console</a>
                    </div>
                </div>
            </div>

            <!-- Game Lobby Section -->
            <div class="game-lobby-section">
                <div class="lobby-icon">üéÆ</div>
                <div class="lobby-content">
                    <h3>Game Lobby</h3>
                    <p>Waiting for players to join...</p>
                </div>
            </div>

            <!-- Main Dashboard Grid -->
            <div class="dashboard-grid">
                <!-- Players Panel -->
                <div class="dashboard-panel">
                    <div class="panel-header">
                        <h3>üë• Players (<span id="playerCount">0</span>)</h3>
                    </div>
                    <div class="player-list" id="playerList">
                        <!-- Players will be populated here -->
                    </div>
                </div>

                <!-- Right Column: Host Controls + Game Settings -->
                <div class="right-column">
                    <!-- Host Controls Panel -->
                    <div class="dashboard-panel">
                        <div class="panel-header">
                            <h3>‚è∞ Host Controls</h3>
                        </div>
                        <div class="host-controls">
                            <button id="startGameBtn" class="control-btn success">START GAME</button>
                            <button id="endGameBtn" class="control-btn" style="background: linear-gradient(135deg, #dc3545, #c82333);">üõë END GAME</button>
                            <button id="gradingBtn" class="control-btn secondary">üìù GRADING INTERFACE</button>
                            <button id="virtualTestBtn" class="control-btn warning">üé≠ VIRTUAL TEST</button>
                            <button id="multiGradingBtn" class="control-btn success">üë• MULTI-USER GRADING</button>
                            <button id="testGameBtn" class="control-btn warning">‚ñ∂Ô∏è TEST GAME</button>
                            <button id="refreshQuestionsBtn" class="control-btn secondary">üîÑ REFRESH QUESTIONS</button>
                        </div>
                    </div>

                    <!-- Game Settings Panel -->
                    <div class="game-settings">
                        <div class="panel-header">
                            <h3>‚öôÔ∏è Game Settings</h3>
                        </div>
                        <div class="settings-grid">
                            <div class="setting-group">
                                <label for="questionSet">Question Set:</label>
                                <select id="questionSet">
                                    <option value="supabase">Supabase Database (Recommended)</option>
                                    <option value="demo">Demo Questions</option>
                                    <option value="custom">Custom Questions</option>
                                </select>
                                <div class="setting-description">Supabase provides a large question database</div>
                            </div>
                            <div class="setting-group">
                                <label for="timerDuration">Timer Duration (seconds):</label>
                                <input type="number" id="timerDuration" value="180" min="30" max="600">
                                <div class="setting-description">Default: 180 seconds (3 minutes)</div>
                            </div>
                            <div class="setting-group">
                                <label for="maxPlayers">Maximum Players:</label>
                                <input type="number" id="maxPlayers" value="0" min="0" max="50">
                                <div class="setting-description">0 = unlimited players</div>
                            </div>
                            <div class="setting-group">
                                <label for="questionsPerRound">Questions per Round:</label>
                                <input type="number" id="questionsPerRound" value="5" min="1" max="20">
                                <div class="setting-description">Number of questions per game round</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Scoring Panel (shown after grading) -->
            <div class="scoring-panel" id="scoringPanel" style="display: none;">
                <div class="scoring-header">
                    <h3>üèÜ Question Results</h3>
                </div>
                <div class="scoring-content" id="scoringContent">
                    <!-- Scoring results will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Single User Grading Interface Modal -->
    <div id="gradingSingleModal" class="modal" style="display: none;">
        <div class="modal-content" id="gradingSingleModalContent">
            <div class="modal-header">
                <h2>üìù Single User Grading Interface</h2>
                <div class="modal-controls">
                    <button id="fullscreenSingleBtn" class="control-btn small" title="Toggle Fullscreen" onclick="toggleSingleModalFullscreen()">‚õ∂</button>
                    <span class="close" onclick="closeGradingSingleModal()">&times;</span>
                </div>
            </div>
            <div class="modal-body">
                <iframe id="gradingSingleFrame" src="/grading-single" width="100%" height="600px" frameborder="0"></iframe>
            </div>
        </div>
    </div>

    <!-- Multi-User Grading Interface Modal -->
    <div id="gradingMultiModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üë• Multi-User Grading Interface</h2>
                <span class="close" onclick="closeGradingMultiModal()">&times;</span>
            </div>
            <div class="modal-body">
                <iframe id="gradingMultiFrame" src="/grading" width="100%" height="600px" frameborder="0"></iframe>
            </div>
        </div>
    </div>

    <script>
        // Socket.IO connection
        let socket = null;
        let currentGame = null;
        let gameState = 'waiting'; // waiting, playing, scoring, finished

        // Initialize connection
        function initializeConnection() {
            socket = io();
            
            socket.on('connect', () => {
                updateConnectionStatus(true);
                
                // Check if we have a saved game session
                const savedGameCode = localStorage.getItem('gameCode');
                
                if (savedGameCode) {
                    // Add a timeout for reconnection
                    const reconnectTimeout = setTimeout(() => {
                        console.log('Reconnection timeout - clearing saved game code');
                        localStorage.removeItem('gameCode');
                        document.getElementById('noGameState').style.display = 'block';
                        document.getElementById('activeGameState').style.display = 'none';
                    }, 3000); // 3 second timeout
                    
                    socket.emit('host-reconnect', { gameCode: savedGameCode });
                    
                    // Clear timeout if reconnection succeeds
                    socket.once('gameCreated', () => {
                        clearTimeout(reconnectTimeout);
                    });
                }
            });
            
            socket.on('disconnect', () => {
                updateConnectionStatus(false);
            });
            
            socket.on('gameCreated', (data) => {
                currentGame = data.gameState;
                // Update gameState to match the actual server state
                if (currentGame && currentGame.gameState) {
                    gameState = currentGame.gameState;
                    console.log('üîÑ Updated gameState to match server:', gameState);
                }
                showActiveGame();
                updateGameDisplay();
                updateGameControls(); // Make sure controls reflect the correct state
                console.log('Game created via socket:', data);
            });
            
            socket.on('playerJoined', (data) => {
                currentGame = data;
                updatePlayerList();
                updateGameDisplay();
            });
            
            socket.on('virtualPlayerJoined', (data) => {
                console.log('üé≠ Virtual player joined event received:', data);
                // Update the current game state with the new virtual player
                if (currentGame && currentGame.players) {
                    // Check if player already exists
                    const existingPlayer = currentGame.players.find(p => p.id === data.playerId);
                    if (!existingPlayer) {
                        currentGame.players.push({
                            id: data.playerId,
                            name: data.playerName,
                            score: 0,
                            isVirtual: true
                        });
                        console.log(`üé≠ Added virtual player ${data.playerName} to host interface`);
                        updatePlayerList();
                        updateGameDisplay();
                    }
                }
                
                // Also update the game state if provided
                if (data.gameState) {
                    currentGame = data.gameState;
                    updateGameDisplay();
                }
            });
            
            socket.on('gameError', (error) => {
                console.error('Game error:', error);
                
                // If it's a reconnection error, clear the saved game code and show the create game form
                if (error.message.includes('Game not found') || error.message.includes('No game found')) {
                    localStorage.removeItem('gameCode');
                    document.getElementById('noGameState').style.display = 'block';
                    document.getElementById('activeGameState').style.display = 'none';
                    console.log('Cleared saved game code due to reconnection error');
                } else {
                    alert('Game error: ' + error.message);
                }
            });
            
            socket.on('gameStarted', (data) => {
                console.log('üéÆ Game started, updating state to playing');
                console.log('üìä Game started data:', data);
                gameState = 'playing';
                console.log('‚úÖ gameState set to:', gameState);
                // Initialize currentAnswerGroups array for tracking responses
                if (currentGame) {
                    currentGame.currentAnswerGroups = [];
                }
                updateGameControls();
                updatePlayerList();
                updateLobbyDisplay();
                
                // Auto-open grading interface when game starts (same as grading button)
                console.log('üéØ Auto-opening grading interface when game starts');
                openGradingSingleModal();
            });
            

            
            socket.on('gameEnded', (data) => {
                console.log('Game completely ended by host:', data);
                gameState = 'waiting';
                
                // Clear saved game code
                localStorage.removeItem('gameCode');
                
                // Reset current game state
                currentGame = null;
                
                // Show create game screen
                document.getElementById('noGameState').style.display = 'block';
                document.getElementById('activeGameState').style.display = 'none';
                
                // Hide scoring panel if it's visible
                document.getElementById('scoringPanel').style.display = 'none';
                
                // Close grading modal if open
                const gradingModal = document.getElementById('gradingSingleModal');
                if (gradingModal.style.display === 'block') {
                    closeGradingSingleModal();
                }
                
                // Close grading window if open
                if (window.gradingWindow && !window.gradingWindow.closed) {
                    window.gradingWindow.close();
                }
                
                console.log('‚úÖ Game ended - reset to create game screen');
            });
            
            socket.on('answerSubmitted', (data) => {
                console.log('üéØ Answer submitted event received:', data);
                console.log('üìä Current game state:', gameState);
                console.log('üìä Current game:', currentGame);
                
                // Update the current game with the new answer
                if (currentGame && currentGame.currentAnswerGroups) {
                    console.log('üìù Updating currentAnswerGroups with new answer');
                    // Find if this player already has an answer
                    const existingIndex = currentGame.currentAnswerGroups.findIndex(group =>
                        group.players && group.players.includes(data.playerName)
                    );

                    if (existingIndex >= 0) {
                        // Update existing answer
                        console.log('üîÑ Updating existing answer for player:', data.playerName);
                        currentGame.currentAnswerGroups[existingIndex].answer = data.answer;
                    } else {
                        // Add new answer group
                        console.log('‚ûï Adding new answer group for player:', data.playerName);
                        currentGame.currentAnswerGroups.push({
                            answer: data.answer,
                            players: [data.playerName],
                            count: 1,
                            points: 0
                        });
                    }
                    console.log('üìä Updated currentAnswerGroups:', currentGame.currentAnswerGroups);
                } else {
                    console.log('‚ùå Cannot update - currentGame or currentAnswerGroups is null');
                }
                updatePlayerList();
            });
            
            socket.on('gameStateUpdate', (data) => {
                if (data.gameState) {
                    currentGame = data.gameState;
                    // Update the gameState variable to match the server state
                    if (currentGame && currentGame.gameState) {
                        gameState = currentGame.gameState;
                        console.log('üîÑ Updated gameState to match server:', gameState);
                    }
                    updatePlayerList();
                    updateGameControls(); // Make sure controls reflect the new state
                }
            });
            
            socket.on('questionComplete', (data) => {
                console.log('Question completed, updating game state:', data);
                currentGame = data;
                gameState = 'grading';
                updateGameDisplay();
                updatePlayerList();
                updateGameControls();
                updateLobbyDisplay();
                
                // Auto-open grading interface when question completes (only if not already open)
                const gradingModal = document.getElementById('gradingSingleModal');
                if (gradingModal.style.display !== 'block' && (!window.gradingWindow || window.gradingWindow.closed)) {
                    console.log('üéØ Auto-opening grading interface for completed question');
                    openGradingWindow();
                } else {
                    console.log('üîÑ Grading interface already open, skipping auto-open');
                }
            });

            socket.on('gradingComplete', (data) => {
                console.log('üìä Grading complete received:', data);
                console.log('üìä Data keys:', Object.keys(data || {}));
                console.log('üìä currentAnswerGroups length:', data?.currentAnswerGroups?.length || 0);
                
                if (data && data.currentAnswerGroups) {
                    console.log('üìä Sample answer group:', data.currentAnswerGroups[0]);
                    console.log('üìä All answer groups with categories:');
                    data.currentAnswerGroups.forEach((group, index) => {
                        console.log(`  ${index + 1}. "${group.answer}" - Category: "${group.category}"`);
                    });
                }
                
                gameState = 'scoring';
                // Update currentGame with the new data that includes recalculated scores
                if (data) {
                    currentGame = data;
                    console.log('üìä Updated currentGame with new scoring data:', currentGame);
                }
                showScoringPanel(data);
                updateGameControls();
                updateLobbyDisplay();
                updatePlayerList(); // Update player list to show new scores
                
                // Force refresh the scoring panel to show updated categorization
                setTimeout(() => {
                    if (data && data.currentAnswerGroups) {
                        console.log('üîÑ Refreshing scoring panel with updated categorization');
                        showScoringPanel(data);
                    }
                }, 500);
            });
            
            socket.on('nextQuestion', (data) => {
                console.log('üîÑ Next question received:', data);
                currentGame = data;
                gameState = 'playing';
                updateGameDisplay();
                updatePlayerList();
                updateGameControls();
                updateLobbyDisplay();
                // Hide scoring panel when moving to next question
                document.getElementById('scoringPanel').style.display = 'none';
                
                // Auto-open grading interface when any question starts (for preparation)
                console.log('üéØ Auto-opening grading interface for question', data.currentQuestion + 1);
                openGradingWindow();
            });
            
            socket.on('roundComplete', (data) => {
                console.log('üéØ Round complete received:', data);
                currentGame = data;
                gameState = 'roundComplete';
                updateGameDisplay();
                updatePlayerList();
                updateGameControls();
                updateLobbyDisplay();
                // Hide scoring panel when round is complete
                document.getElementById('scoringPanel').style.display = 'none';
            });
            
            socket.on('error', (error) => {
                console.error('Socket error:', error);
            });
        }

        // Update connection status
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionIndicator');
            const status = document.getElementById('connectionStatus');
            
            if (connected) {
                indicator.className = 'status-indicator status-connected';
                status.textContent = 'Connected to server';
            } else {
                indicator.className = 'status-indicator status-disconnected';
                status.textContent = 'Disconnected from server';
            }
        }

        // Show active game interface
        function showActiveGame() {
            document.getElementById('noGameState').style.display = 'none';
            document.getElementById('activeGameState').style.display = 'block';
        }

        // Update game display
        function updateGameDisplay() {
            if (!currentGame) return;
            
            document.getElementById('gameCodeDisplay').textContent = currentGame.gameCode;
            document.getElementById('playerCount').textContent = currentGame.players.size || 0;
            
            updateLobbyDisplay();
            updatePlayerList();
        }

        // Update player list
        function updatePlayerList() {
            if (!currentGame) return;
            
            console.log('üîÑ updatePlayerList called');
            console.log('üìä gameState:', gameState);
            console.log('üìä currentAnswerGroups:', currentGame.currentAnswerGroups);
            
            const playerList = document.getElementById('playerList');
            const playerCount = document.getElementById('playerCount');
            playerList.innerHTML = '';
            
            // Update player count
            const playerCountValue = Object.keys(currentGame.players).length;
            playerCount.textContent = playerCountValue;
            
            currentGame.players.forEach((player, socketId) => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                // Check if player has a response for the current question
                let responseDisplay = '';
                let questionPoints = 0;
                
                if ((gameState === 'playing' || gameState === 'grading' || gameState === 'scoring') && currentGame.currentAnswerGroups) {
                    const playerResponse = currentGame.currentAnswerGroups.find(group =>
                        group.players && group.players.includes(player.name)
                    );
                    if (playerResponse) {
                        console.log('‚úÖ Found response for player:', player.name, 'Answer:', playerResponse.answer, 'Points:', playerResponse.points);
                        questionPoints = playerResponse.points || 0;
                        responseDisplay = `
                            <div class="player-response">
                                <span class="response-label">Answer:</span>
                                <span class="response-text">"${playerResponse.answer}"</span>
                                ${gameState === 'scoring' ? `<span class="response-points">(+${questionPoints} pts)</span>` : ''}
                            </div>
                        `;
                    } else if (gameState === 'playing') {
                        console.log('‚è≥ Player waiting for answer:', player.name);
                        responseDisplay = `
                            <div class="player-response">
                                <span class="response-label">Status:</span>
                                <span class="response-status waiting">Waiting for answer...</span>
                            </div>
                        `;
                    }
                }
                
                playerItem.innerHTML = `
                    <div class="player-info">
                        <div class="player-avatar">${player.name.charAt(0).toUpperCase()}</div>
                        <div class="player-details">
                            <div class="player-name">${player.name}</div>

                            ${responseDisplay}
                        </div>
                    </div>
                    <div class="player-score">Score: ${player.score || 0}</div>
                `;
                playerList.appendChild(playerItem);
            });
        }



        // Update player list when answers are submitted
        function updatePlayerListWithResponses() {
            updatePlayerList();
        }

        // Update game controls based on current state
        function updateGameControls() {
            const startBtn = document.getElementById('startGameBtn');
            const endGameBtn = document.getElementById('endGameBtn');
            
            console.log('üîÑ updateGameControls called with gameState:', gameState);
            console.log('üîç endGameBtn element:', endGameBtn);
            
            if (gameState === 'waiting') {
                startBtn.textContent = 'START GAME';
                startBtn.className = 'control-btn success';
                startBtn.disabled = false;
                endGameBtn.style.display = 'none'; // Hide end game button when waiting
                console.log('‚è≥ Game state: waiting - End Game button hidden');
            } else if (gameState === 'playing') {
                startBtn.textContent = 'GAME IN PROGRESS';
                startBtn.className = 'control-btn secondary';
                startBtn.disabled = true;
                endGameBtn.style.display = 'inline-flex'; // Show end game button when playing
                console.log('üéÆ Game state: playing - End Game button shown');
            } else if (gameState === 'grading') {
                startBtn.textContent = 'GRADING IN PROGRESS';
                startBtn.className = 'control-btn warning';
                startBtn.disabled = true;
                endGameBtn.style.display = 'inline-flex';
                console.log('üìù Game state: grading - End Game button shown');
            } else if (gameState === 'scoring') {
                // Check if current question is the last in the round
                const currentQuestionNumber = currentGame?.currentQuestion || 0;
                const questionsPerRound = currentGame?.questionsPerRound || 5;
                const questionInRound = ((currentQuestionNumber) % questionsPerRound) + 1;
                
                console.log(`üîç Button logic: currentQuestion=${currentQuestionNumber}, questionsPerRound=${questionsPerRound}, questionInRound=${questionInRound}`);
                console.log(`üîç currentGame object:`, currentGame);
                
                if (questionInRound === questionsPerRound) {
                    // Current question is the last in the round
                    startBtn.textContent = 'END ROUND';
                    console.log(`üéØ Button text set to END ROUND (current question ${currentQuestionNumber} is last in round)`);
                } else {
                    // Regular next question
                    startBtn.textContent = 'NEXT QUESTION';
                    console.log(`‚û°Ô∏è Button text set to NEXT QUESTION (current question ${currentQuestionNumber}, question in round: ${questionInRound})`);
                }
                
                startBtn.className = 'control-btn success';
                startBtn.disabled = false;
                endGameBtn.style.display = 'inline-flex';
                console.log('üèÜ Game state: scoring - End Game button shown');
            } else if (gameState === 'roundComplete') {
                // Check if this is the final round
                const currentRound = currentGame?.currentRound || 1;
                const totalRounds = currentGame?.totalRounds || 5;
                
                // For roundComplete state, we need to determine which round just finished
                // The currentQuestion represents the last question of the completed round
                const currentQuestion = currentGame?.currentQuestion || 0;
                const questionsPerRound = currentGame?.questionsPerRound || 5;
                const completedRound = Math.ceil(currentQuestion / questionsPerRound);
                
                console.log(`üîç Round complete calculation debug:`);
                console.log(`  - currentGame.currentRound: ${currentGame?.currentRound}`);
                console.log(`  - currentQuestion: ${currentQuestion}`);
                console.log(`  - questionsPerRound: ${questionsPerRound}`);
                console.log(`  - completedRound: ${completedRound}`);
                
                if (completedRound >= totalRounds) {
                    startBtn.textContent = 'END GAME';
                    console.log(`üèÅ Button text set to END GAME (completed round ${completedRound}/${totalRounds})`);
                } else if (completedRound === 1) {
                    // After first round, show START NEXT ROUND
                    startBtn.textContent = 'START NEXT ROUND';
                    console.log(`üîÑ Button text set to START NEXT ROUND (completed round ${completedRound}/${totalRounds})`);
                } else {
                    // After rounds 2+, show OVERALL LEADERBOARD
                    startBtn.textContent = 'OVERALL LEADERBOARD';
                    console.log(`üìä Button text set to OVERALL LEADERBOARD (completed round ${completedRound}/${totalRounds})`);
                }
                
                startBtn.className = 'control-btn success';
                startBtn.disabled = false;
                endGameBtn.style.display = 'inline-flex';
                console.log('üìä Game state: roundComplete - End Game button shown');
            } else if (gameState === 'overallLeaderboard') {
                // Check if this is the final round
                const currentQuestion = currentGame?.currentQuestion || 0;
                const questionsPerRound = currentGame?.questionsPerRound || 5;
                const completedRound = Math.ceil(currentQuestion / questionsPerRound);
                const totalRounds = currentGame?.totalRounds || 5;
                
                console.log(`üîç Overall leaderboard calculation debug:`);
                console.log(`  - currentQuestion: ${currentQuestion}`);
                console.log(`  - questionsPerRound: ${questionsPerRound}`);
                console.log(`  - completedRound: ${completedRound}`);
                console.log(`  - totalRounds: ${totalRounds}`);
                
                if (completedRound >= totalRounds) {
                    // This is the final round, show END GAME
                    startBtn.textContent = 'END GAME';
                    startBtn.className = 'control-btn danger';
                    console.log(`üèÅ Button text set to END GAME (final round ${completedRound}/${totalRounds})`);
                } else {
                    // Not the final round, show START NEXT ROUND
                    startBtn.textContent = 'START NEXT ROUND';
                    startBtn.className = 'control-btn success';
                    console.log(`üîÑ Button text set to START NEXT ROUND (round ${completedRound}/${totalRounds})`);
                }
                
                startBtn.disabled = false;
                endGameBtn.style.display = 'inline-flex';
                console.log('üìä Game state: overallLeaderboard - End Game button shown');
            } else if (gameState === 'finished') {
                startBtn.textContent = 'GAME FINISHED';
                startBtn.className = 'control-btn secondary';
                startBtn.disabled = true;
                endGameBtn.style.display = 'none';
                console.log('üèÅ Game state: finished - Game completed');
            } else {
                console.log('‚ùì Unknown game state:', gameState);
            }
        }

        // Update lobby display
        function updateLobbyDisplay() {
            const lobbyContent = document.querySelector('.lobby-content');
            if (!lobbyContent) return;

            const lobbyTitle = lobbyContent.querySelector('h3');
            const lobbyText = lobbyContent.querySelector('p');

            if (gameState === 'waiting') {
                lobbyTitle.textContent = 'Game Lobby';
                lobbyText.textContent = 'Waiting for players to join...';
            } else if (gameState === 'playing') {
                lobbyTitle.textContent = 'Game in Progress';
                lobbyText.textContent = 'Players are answering questions...';
            } else if (gameState === 'grading') {
                lobbyTitle.textContent = 'Grading Phase';
                lobbyText.textContent = 'Grading player responses...';
            } else if (gameState === 'scoring') {
                lobbyTitle.textContent = 'Scoring Phase';
                lobbyText.textContent = 'Question completed - view results below';
            }
        }

        // Show scoring panel
        function showScoringPanel(data) {
            const scoringPanel = document.getElementById('scoringPanel');
            const scoringContent = document.getElementById('scoringContent');
            
            scoringPanel.style.display = 'block';
            
            console.log('üéØ showScoringPanel called with data:', data);
            
            if (data && data.currentAnswerGroups) {
                console.log('üìä currentAnswerGroups received:', data.currentAnswerGroups);
                console.log('üìä Number of answer groups:', data.currentAnswerGroups.length);
                
                scoringContent.innerHTML = '';
                
                // Group answers by category
                const correctAnswers = [];
                const wrongAnswers = [];
                const uncategorizedAnswers = [];
                
                (data.currentAnswerGroups || []).forEach((group, index) => {
                    console.log(`üìù Answer ${index + 1}: "${group.answer}" - Category: "${group.category}"`);
                    
                    if (group.category === 'correct') {
                        correctAnswers.push(group);
                        console.log(`‚úÖ Added to correct: "${group.answer}"`);
                    } else if (group.category === 'wrong') {
                        wrongAnswers.push(group);
                        console.log(`‚ùå Added to wrong: "${group.answer}"`);
                    } else {
                        uncategorizedAnswers.push(group);
                        console.log(`üì¶ Added to uncategorized: "${group.answer}"`);
                    }
                });
                
                console.log(`üìä Summary: ${correctAnswers.length} correct, ${wrongAnswers.length} wrong, ${uncategorizedAnswers.length} uncategorized`);
                
                // Create sections for each category
                if (correctAnswers.length > 0) {
                    const correctSection = createScoringSection('‚úÖ Correct Answers', correctAnswers, '#28a745');
                    scoringContent.appendChild(correctSection);
                }
                
                if (wrongAnswers.length > 0) {
                    const wrongSection = createScoringSection('‚ùå Wrong Answers', wrongAnswers, '#e74c3c');
                    scoringContent.appendChild(wrongSection);
                }
                
                if (uncategorizedAnswers.length > 0) {
                    const uncategorizedSection = createScoringSection('üì¶ Uncategorized Answers', uncategorizedAnswers, '#f39c12');
                    scoringContent.appendChild(uncategorizedSection);
                }
            } else {
                console.log('‚ùå No data or currentAnswerGroups in showScoringPanel');
            }
        }

        // Create scoring section
        function createScoringSection(title, answers, color) {
            const section = document.createElement('div');
            section.className = 'scoring-section';
            
            const header = document.createElement('h4');
            header.textContent = title;
            header.style.color = color;
            section.appendChild(header);
            
            // Create scrollable container for answers
            const answersContainer = document.createElement('div');
            answersContainer.className = 'answers-container';
            answersContainer.style.cssText = `
                max-height: 300px;
                overflow-y: auto;
                padding: 10px;
                border-radius: 8px;
                background: rgba(255, 255, 255, 0.05);
                margin-top: 10px;
            `;
            
            answers.forEach(answer => {
                const answerGroup = document.createElement('div');
                answerGroup.className = 'answer-group';
                answerGroup.style.cssText = `
                    background: rgba(255, 255, 255, 0.1);
                    padding: 12px;
                    margin: 8px 0;
                    border-radius: 6px;
                    border-left: 4px solid ${color};
                `;
                
                const answerText = document.createElement('div');
                answerText.className = 'answer-text';
                answerText.textContent = `"${answer.answer}"`;
                answerText.style.cssText = `
                    font-weight: bold;
                    font-size: 16px;
                    color: white;
                    margin-bottom: 4px;
                `;
                
                const answerPlayers = document.createElement('div');
                answerPlayers.className = 'answer-players';
                answerPlayers.textContent = `Players: ${answer.players.join(', ')}`;
                answerPlayers.style.cssText = `
                    font-size: 14px;
                    color: #ccc;
                    margin-bottom: 4px;
                `;
                
                const answerPoints = document.createElement('div');
                answerPoints.className = 'answer-points';
                answerPoints.textContent = `Points: ${answer.points || 0}`;
                answerPoints.style.cssText = `
                    font-size: 14px;
                    color: ${color};
                    font-weight: bold;
                `;
                
                answerGroup.appendChild(answerText);
                answerGroup.appendChild(answerPlayers);
                answerGroup.appendChild(answerPoints);
                answersContainer.appendChild(answerGroup);
            });
            
            section.appendChild(answersContainer);
            return section;
        }

        // Copy game code
        function copyGameCode() {
            const gameCode = document.getElementById('gameCodeDisplay').textContent;
            navigator.clipboard.writeText(gameCode).then(() => {
                // Show feedback
                const copyBtn = document.querySelector('.copy-btn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            });
        }

        // Event listeners
        document.getElementById('createGameBtn').addEventListener('click', async () => {
            try {
                // Create game via API
                const response = await fetch('/api/create-game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    // Store game info
                    localStorage.setItem('gameCode', data.gameCode);
                    
                    // Join the game room via socket
                    socket.emit('createGame');
                    
                    console.log('Game created successfully:', data);
                } else {
                    alert('Failed to create game: ' + data.message);
                }
            } catch (error) {
                console.error('Error creating game:', error);
                alert('Error creating game. Please try again.');
            }
        });

        document.getElementById('startGameBtn').addEventListener('click', () => {
            if (gameState === 'waiting' && currentGame) {
                socket.emit('startGame', { gameCode: currentGame.gameCode });
            } else if (gameState === 'scoring' && currentGame) {
                socket.emit('nextQuestion', { gameCode: currentGame.gameCode });
            } else if (gameState === 'roundComplete' && currentGame) {
                // Get the round that was just completed from round history
                const roundHistory = currentGame.roundHistory || [];
                const lastCompletedRound = roundHistory.length > 0 ? roundHistory[roundHistory.length - 1].roundNumber : 0;
                const totalRounds = currentGame.totalRounds || 5;
                
                if (lastCompletedRound >= totalRounds) {
                    // Final round completed - end the game
                    socket.emit('endGame', { gameCode: currentGame.gameCode });
                } else if (lastCompletedRound === 1) {
                    // After first round - continue to next round
                    socket.emit('continueToNextRound', { gameCode: currentGame.gameCode });
                } else {
                    // After rounds 2+ - show overall leaderboard
                    socket.emit('showOverallLeaderboard', { gameCode: currentGame.gameCode });
                }
            } else if (gameState === 'overallLeaderboard' && currentGame) {
                // Check if this is the final round
                const currentQuestion = currentGame?.currentQuestion || 0;
                const questionsPerRound = currentGame?.questionsPerRound || 5;
                const completedRound = Math.ceil(currentQuestion / questionsPerRound);
                const totalRounds = currentGame?.totalRounds || 5;
                
                if (completedRound >= totalRounds) {
                    // This is the final round, end the game
                    socket.emit('endGame', { gameCode: currentGame.gameCode });
                } else {
                    // Not the final round, continue to next round
                    socket.emit('continueToNextRound', { gameCode: currentGame.gameCode });
                }
            }
        });

        document.getElementById('testGameBtn').addEventListener('click', () => {
            // Open test game in new tab
            window.open('/game', '_blank');
        });

        document.getElementById('refreshQuestionsBtn').addEventListener('click', () => {
            // Refresh questions from server
            socket.emit('refresh-questions');
        });

        document.getElementById('endGameBtn').addEventListener('click', () => {
            if (currentGame && confirm('Are you sure you want to end the current game? This will reset the game state and remove all players.')) {
                socket.emit('endGame', { gameCode: currentGame.gameCode });
            }
        });

        // Grading modal functions
        function openGradingSingleModal() {
            document.getElementById('gradingSingleModal').style.display = 'block';
            // Apply fullscreen by default
            document.getElementById('gradingSingleModalContent').classList.add('fullscreen');
            // Refresh the iframe content with game code parameter
            const gameCode = currentGame ? currentGame.gameCode : null;
            const url = gameCode ? `/grading-single?gameCode=${gameCode}` : '/grading-single';
            document.getElementById('gradingSingleFrame').src = url;
        }
        
        // Function to open grading interface in new window (for automatic opening)
        function openGradingWindow() {
            // Always use modal instead of popup
            console.log('üìù Opening grading interface as modal');
            openGradingSingleModal();
        }

        // Function to get current game code for the grading interface
        function getCurrentGameCode() {
            return currentGame ? currentGame.gameCode : null;
        }

        function closeGradingSingleModal() {
            document.getElementById('gradingSingleModal').style.display = 'none';
            // Remove fullscreen class when closing
            document.getElementById('gradingSingleModalContent').classList.remove('fullscreen');
        }

        function openGradingMultiModal() {
            document.getElementById('gradingMultiModal').style.display = 'block';
            // Refresh the iframe content
            document.getElementById('gradingMultiFrame').src = '/grading';
        }

            function closeGradingMultiModal() {
        document.getElementById('gradingMultiModal').style.display = 'none';
    }

    function toggleSingleModalFullscreen() {
        const modalContent = document.getElementById('gradingSingleModalContent');
        const fullscreenBtn = document.getElementById('fullscreenSingleBtn');
        
        if (modalContent.classList.contains('fullscreen')) {
            // Exit fullscreen
            modalContent.classList.remove('fullscreen');
            fullscreenBtn.textContent = '‚õ∂';
            fullscreenBtn.title = 'Enter Fullscreen';
        } else {
            // Enter fullscreen
            modalContent.classList.add('fullscreen');
            fullscreenBtn.textContent = '‚õ∂';
            fullscreenBtn.title = 'Exit Fullscreen';
        }
    }

    // Close modals when clicking outside of them
    window.onclick = function(event) {
        const singleModal = document.getElementById('gradingSingleModal');
        const multiModal = document.getElementById('gradingMultiModal');
        
        if (event.target === singleModal) {
            closeGradingSingleModal();
        }
        if (event.target === multiModal) {
            closeGradingMultiModal();
        }
    }

        // Grading interface buttons
        document.getElementById('gradingBtn').addEventListener('click', () => {
            openGradingSingleModal();
        });

        document.getElementById('multiGradingBtn').addEventListener('click', () => {
            openGradingMultiModal();
        });

        // Virtual test button
        document.getElementById('virtualTestBtn').addEventListener('click', () => {
            console.log('üé≠ Virtual test button clicked');
            startFullGameSimulation();
        });

        // Virtual player testing system
        const virtualPlayerNames = [
            'Alice Johnson', 'Bob Smith', 'Carol Davis', 'David Wilson', 'Emma Brown',
            'Frank Miller', 'Grace Lee', 'Henry Taylor', 'Ivy Chen', 'Jack Anderson',
            'Kate Martinez', 'Liam O\'Connor', 'Maya Patel', 'Noah Garcia', 'Olivia Kim',
            'Paul Rodriguez', 'Quinn Thompson', 'Ruby Singh', 'Sam Johnson', 'Tara Williams',
            'Uma Davis', 'Victor Chen', 'Wendy Brown', 'Xander Lee', 'Yara Martinez',
            'Zoe Anderson', 'Alex Turner', 'Blake Johnson', 'Casey Smith', 'Drew Wilson',
            'Eden Davis', 'Finley Brown', 'Gray Miller', 'Harper Lee', 'Indigo Chen',
            'Jordan Taylor', 'Kai Martinez', 'Luna Patel', 'Mason Garcia', 'Nova Kim',
            'Ocean Rodriguez', 'Phoenix Thompson', 'Quill Singh', 'River Williams', 'Sage Davis',
            'Terra Chen', 'Umber Brown', 'Vale Lee', 'Wren Martinez', 'Xylo Anderson',
            'Yarrow Turner', 'Zephyr Johnson', 'Aster Smith', 'Birch Wilson', 'Cedar Davis',
            'Dawn Brown', 'Echo Miller', 'Flora Lee', 'Grove Chen', 'Haven Taylor'
        ];
        
        let virtualPlayers = [];
        let virtualPlayerInterval = null;
        let virtualResponseInterval = null;
        let questionCount = 0;
        let isVirtualTestingMode = false;
        
        function startVirtualPlayerSimulation() {
            console.log('üé≠ Starting virtual player simulation...');
            console.log('üé≠ Current game:', currentGame);
            console.log('üé≠ Socket connected:', !!socket);
            isVirtualTestingMode = true;
            virtualPlayers = [];
            
            // Add 60 virtual players over 30 seconds
            const addPlayerInterval = setInterval(() => {
                if (virtualPlayers.length >= 60) {
                    clearInterval(addPlayerInterval);
                    console.log('‚úÖ All 60 virtual players added');
                    return;
                }
                
                const playerName = virtualPlayerNames[virtualPlayers.length];
                // Generate truly unique ID using timestamp + random number
                const uniqueId = `virtual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${virtualPlayers.length}`;
                const virtualPlayer = {
                    id: uniqueId,
                    name: playerName,
                    score: 0,
                    isVirtual: true
                };
                
                virtualPlayers.push(virtualPlayer);
                
                console.log(`üé≠ Attempting to add virtual player ${playerName} (${virtualPlayers.length}/60) with ID: ${uniqueId}`);
                
                // Emit a custom event to update the server
                if (socket && currentGame) {
                    console.log(`üé≠ Emitting virtualPlayerJoined for ${playerName} to game ${currentGame.gameCode}`);
                    socket.emit('virtualPlayerJoined', {
                        gameCode: currentGame.gameCode,
                        playerId: uniqueId,
                        playerName: playerName
                    });
                } else {
                    console.error('‚ùå Cannot emit virtualPlayerJoined - socket or currentGame is null');
                }
                
            }, 500); // Add a player every 500ms (30 seconds total for 60 players)
            
            virtualPlayerInterval = addPlayerInterval;
        }
        
        function generateVirtualResponses(question) {
            console.log('üé≠ Generating virtual responses for question:', question.text);
            
            virtualPlayers.forEach((player, index) => {
                // Simulate response time (0.5 to 3 seconds)
                const responseDelay = 500 + Math.random() * 2500;
                
                setTimeout(() => {
                    let response;
                    let isCorrect;
                    
                    // 75% correct answers, 25% incorrect
                    if (Math.random() < 0.75) {
                        response = question.correctAnswer;
                        isCorrect = true;
                    } else {
                        // Generate incorrect answers
                        const incorrectAnswers = [
                            'I don\'t know',
                            'Maybe',
                            'Not sure',
                            'Could be',
                            'Possibly',
                            'I think so',
                            'Probably not',
                            'Definitely not'
                        ];
                        response = incorrectAnswers[Math.floor(Math.random() * incorrectAnswers.length)];
                        isCorrect = false;
                    }
                    
                    // 20% of correct answers should be modified for manual grading
                    if (isCorrect && Math.random() < 0.2) {
                        response = modifyAnswerForGrading(response);
                    }
                    
                    // Emit the response via virtual answer submission
                    if (socket) {
                        socket.emit('virtualAnswerSubmitted', {
                            gameCode: currentGame.gameCode,
                            playerId: player.id,
                            playerName: player.name,
                            answer: response,
                            isCorrect: isCorrect
                        });
                    }
                    
                    console.log(`üé≠ Virtual player ${player.name} answered: "${response}" (${isCorrect ? 'correct' : 'incorrect'})`);
                    
                }, responseDelay);
            });
        }
        
        function modifyAnswerForGrading(answer) {
            const modifications = [
                answer + ' (I think)',
                answer + ' maybe',
                answer + ' probably',
                answer + ' I believe',
                answer + ' seems right',
                answer + ' sounds correct',
                answer + ' I guess',
                answer + ' most likely'
            ];
            return modifications[Math.floor(Math.random() * modifications.length)];
        }
        
        function simulateQuestionCycle() {
            questionCount++;
            console.log(`üé≠ Simulating question cycle ${questionCount}`);
            
            // Generate responses for current question
            if (currentGame && currentGame.currentQuestion) {
                generateVirtualResponses(currentGame.currentQuestion);
            }
            
            // Move to grading phase after 5 seconds
            setTimeout(() => {
                console.log('üé≠ Moving to grading phase');
                // Trigger grading phase
                if (socket) {
                    socket.emit('startGrading', { gameCode: currentGame.gameCode });
                }
            }, 5000);
        }
        
        function startFullGameSimulation() {
            console.log('üéÆ Starting full game simulation from host interface...');
            
            // Initialize game state if not already set
            if (!currentGame) {
                console.error('‚ùå No active game found');
                return;
            }
            
            // Start virtual player simulation
            startVirtualPlayerSimulation();
            
            console.log('‚úÖ Full game simulation started. Virtual players will join over 30 seconds.');
            console.log('The display will stay on the QR code screen while players join.');
            console.log('Use these commands for manual control:');
            console.log('  startGame() - Start the game when ready');
            console.log('  nextQuestion() - Move to next question');
            console.log('  finishGrading() - Complete grading phase');
        }
        
        function startGame() {
            if (socket && currentGame) {
                socket.emit('startGame', { gameCode: currentGame.gameCode });
                console.log('üéÆ Game started');
            }
        }
        
        function nextQuestion() {
            if (socket && currentGame) {
                socket.emit('nextQuestion', { gameCode: currentGame.gameCode });
                console.log('üéÆ Next question requested');
            }
        }
        
        function finishGrading() {
            if (socket && currentGame) {
                socket.emit('finishGrading', { gameCode: currentGame.gameCode });
                console.log('üéÆ Grading completed');
            }
        }
        
        // Make functions globally available
        window.startFullGameSimulation = startFullGameSimulation;
        window.startGame = startGame;
        window.nextQuestion = nextQuestion;
        window.finishGrading = finishGrading;
        
        function updatePlayerCount() {
            const playerCountElement = document.querySelector('.player-count');
            if (playerCountElement) {
                const totalPlayers = virtualPlayers.length + (currentGame ? currentGame.players ? currentGame.players.length : 0 : 0);
                playerCountElement.textContent = totalPlayers;
            }
        }
        
        // Socket event listeners for virtual testing
        if (socket) {
            socket.on('gameStarted', (data) => {
                console.log('üéÆ Game started, virtual players will respond to questions');
            });
            
            socket.on('questionDisplayed', (data) => {
                console.log('üé≠ Question displayed, generating virtual responses...');
                if (isVirtualTestingMode && data.question) {
                    // Wait 2 seconds then generate responses
                    setTimeout(() => {
                        generateVirtualResponses(data.question);
                    }, 2000);
                }
            });
            
            socket.on('gradingStarted', (data) => {
                console.log('üé≠ Grading started, virtual players have submitted responses');
            });
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Listen for messages from grading interface to close it
            window.addEventListener('message', (event) => {
                if (event.data === 'closeGradingInterface') {
                    console.log('üéØ Received closeGradingInterface message from grading interface');
                    
                    // Close the grading modal (iframe)
                    const gradingModal = document.getElementById('gradingSingleModal');
                    if (gradingModal) {
                        console.log('üéØ Closing grading interface modal');
                        gradingModal.style.display = 'none';
                    }
                    
                    // Also close popup window if it exists
                    if (window.gradingWindow && !window.gradingWindow.closed) {
                        console.log('üéØ Closing grading interface window');
                        window.gradingWindow.close();
                        window.gradingWindow = null;
                    }
                }
            });
            initializeConnection();
        });

        // Keyboard shortcuts for modal fullscreen
        document.addEventListener('keydown', (e) => {
            const singleModal = document.getElementById('gradingSingleModal');
            const modalContent = document.getElementById('gradingSingleModalContent');
            
            // Only handle keyboard shortcuts when the single user grading modal is open
            if (singleModal.style.display === 'block') {
                // F11 key to toggle fullscreen
                if (e.key === 'F11') {
                    e.preventDefault();
                    toggleSingleModalFullscreen();
                }
                
                // Escape key to exit fullscreen
                if (e.key === 'Escape' && modalContent.classList.contains('fullscreen')) {
                    toggleSingleModalFullscreen();
                }
            }
        });
    </script>
</body>
</html> 