<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>MEGASheep Display</title>
    <link rel="stylesheet" href="styles.css?v=20241220">
    <style>
        /* Dynamic scaling based on screen resolution */
        :root {
            --scale-factor: 0.65;
            --font-scale: 0.65;
        }
        
        /* JavaScript will update these values based on screen resolution */
        
        /* Base scaling for 1920x1080 */
        @media screen and (max-width: 1920px) {
            :root {
                --scale-factor: 0.65;
                --font-scale: 0.65;
            }
        }
        
        /* Larger scaling for 2560x1600 and similar high-res displays */
        @media screen and (min-width: 2560px) {
            :root {
                --scale-factor: 0.85;
                --font-scale: 0.85;
            }
        }
        
        /* Medium scaling for 1920x1200 and similar */
        @media screen and (min-width: 1921px) and (max-width: 2559px) {
            :root {
                --scale-factor: 0.75;
                --font-scale: 0.75;
            }
        }
        
        /* Modern Player Card Animations */
        @keyframes cardSlideIn {
            0% {
                transform: translateY(30px) scale(0.8);
                opacity: 0;
            }
            60% {
                transform: translateY(-5px) scale(1.05);
                opacity: 1;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes cardPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(0, 123, 255, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        @keyframes scoreGlow {
            0%, 100% {
                text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
            }
            50% {
                text-shadow: 0 0 15px rgba(0, 255, 136, 0.9), 0 0 25px rgba(0, 255, 136, 0.5);
            }
        }

        /* Staggered animation delay for cards */
        .modern-player-card:nth-child(1) { animation-delay: 0ms; }
        .modern-player-card:nth-child(2) { animation-delay: 50ms; }
        .modern-player-card:nth-child(3) { animation-delay: 100ms; }
        .modern-player-card:nth-child(4) { animation-delay: 150ms; }
        .modern-player-card:nth-child(5) { animation-delay: 200ms; }
        .modern-player-card:nth-child(6) { animation-delay: 250ms; }
        .modern-player-card:nth-child(7) { animation-delay: 300ms; }
        .modern-player-card:nth-child(8) { animation-delay: 350ms; }
        .modern-player-card:nth-child(9) { animation-delay: 400ms; }
        .modern-player-card:nth-child(10) { animation-delay: 450ms; }
        .modern-player-card:nth-child(11) { animation-delay: 500ms; }
        .modern-player-card:nth-child(12) { animation-delay: 550ms; }
        .modern-player-card:nth-child(13) { animation-delay: 600ms; }
        .modern-player-card:nth-child(14) { animation-delay: 650ms; }
        .modern-player-card:nth-child(15) { animation-delay: 700ms; }
        .modern-player-card:nth-child(16) { animation-delay: 750ms; }
        .modern-player-card:nth-child(17) { animation-delay: 800ms; }
        .modern-player-card:nth-child(18) { animation-delay: 850ms; }
        .modern-player-card:nth-child(19) { animation-delay: 900ms; }
        .modern-player-card:nth-child(20) { animation-delay: 950ms; }

        /* For cards beyond 20, use base delay (advanced calc removed for compatibility) */
        .modern-player-card:nth-child(n+21) { animation-delay: 0ms; }

        /* Hover effects for modern cards */
        .modern-player-card:hover {
            transform: translateY(-8px) scale(1.05) !important;
            border-color: rgba(0, 123, 255, 0.8) !important;
            background: linear-gradient(135deg, rgba(0, 123, 255, 0.35), rgba(0, 86, 179, 0.25)) !important;
            box-shadow: 0 8px 25px rgba(0, 123, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
            animation: cardPulse 1.5s ease-in-out infinite !important;
        }

        /* Shimmer effect overlay */
        .modern-player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.15),
                transparent
            );
            transition: left 0.6s ease;
            border-radius: 12px;
        }

        .modern-player-card:hover::before {
            left: 100%;
        }

        /* Enhanced text styling */
        .modern-player-name {
            font-size: calc(1.3rem * var(--font-scale)) !important;
            color: #ffffff !important;
            font-weight: 700 !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            line-height: 1.1 !important;
            flex: 1 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            width: 100% !important;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7), 0 0 8px rgba(0, 123, 255, 0.3) !important;
            letter-spacing: 0.5px !important;
            transition: all 0.3s ease !important;
        }

        .modern-player-score {
            font-size: calc(1.1rem * var(--font-scale)) !important;
            color: #00ff88 !important;
            font-weight: 800 !important;
            white-space: nowrap !important;
            line-height: 1 !important;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.7), 0 2px 4px rgba(0, 0, 0, 0.8) !important;
            letter-spacing: 0.3px !important;
            background: linear-gradient(45deg, #00ff88, #00cc6a) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
            animation: scoreGlow 2s ease-in-out infinite !important;
            transition: all 0.3s ease !important;
        }

        /* Special effects for top players */
        .modern-player-card.top-player {
            border-color: rgba(255, 215, 0, 0.8) !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.25), rgba(255, 179, 0, 0.15)) !important;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
        }

        .modern-player-card.top-player::after {
            content: 'üëë';
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #ffd700, #ffb300);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
            animation: cardPulse 2s ease-in-out infinite;
        }

        /* Host player special styling */
        .modern-player-card.host-player {
            border-color: rgba(255, 255, 255, 0.8) !important;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1)) !important;
        }

        .modern-player-card.host-player::after {
            content: '‚≠ê';
            position: absolute;
            top: -8px;
            left: -8px;
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            color: #333;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.4);
        }

        /* Main two-column layout for display screen */
        .display-main-container {
            display: grid;
            grid-template-columns: 75% 25%;
            gap: calc(20px * var(--scale-factor));
            height: 100vh;
            width: 100vw;
            padding: calc(20px * var(--scale-factor));
            box-sizing: border-box;
            align-items: start;
        }

        /* Left column: Question Results */
        .question-results-section {
            display: flex;
            flex-direction: column;
            background: rgba(0, 40, 80, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.2);
            border-radius: calc(15px * var(--scale-factor));
            padding: calc(18px * var(--scale-factor));
            overflow: hidden;
        }

        /* Right column: Current Scores */
        .current-scores-section {
            display: flex;
            flex-direction: column;
            background: rgba(0, 40, 80, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.2);
            border-radius: calc(15px * var(--scale-factor));
            padding: calc(18px * var(--scale-factor));
            overflow: hidden;
        }

        /* Headers for both sections */
        .scoring-header, .scores-header {
            text-align: center;
            margin: 0 0 calc(20px * var(--scale-factor)) 0;
            flex-shrink: 0;
            background: rgba(0, 0, 0, 0.6);
            border-radius: calc(10px * var(--scale-factor));
            padding: calc(15px * var(--scale-factor));
        }

        .scoring-header h1, .scores-header h1 {
            color: #e8e8e8 !important;
            font-size: calc(2.8rem * var(--font-scale));
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            margin: 0;
            font-weight: bold;
            -webkit-text-fill-color: #e8e8e8 !important;
            background: none !important;
            text-align: center;
        }

        .scoring-subtitle {
            color: #cccccc;
            font-size: calc(1.3rem * var(--font-scale));
            margin: 10px 0 0 0;
        }



        /* Content areas */
        .scoring-content {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: calc(12px * var(--scale-factor));
        }

        .scores-content {
            flex: 1;
            overflow-y: auto;
        }

        /* Navigation footer */
        .scoring-navigation {
            flex-shrink: 0;
            text-align: center;
            margin-top: calc(20px * var(--scale-factor));
            padding: calc(15px * var(--scale-factor));
            background: rgba(0, 123, 255, 0.1);
            border-radius: calc(10px * var(--scale-factor));
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        .scoring-navigation p {
            color: #ffffff;
            font-size: calc(1.1rem * var(--font-scale));
            margin: 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        /* Compact scores for sidebar */
        .compact-scores-list {
            display: flex;
            flex-direction: column;
            gap: calc(8px * var(--scale-factor));
        }

        .compact-score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: calc(8px * var(--scale-factor));
            padding: calc(8px * var(--scale-factor)) calc(12px * var(--scale-factor));
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .compact-score-name {
            color: #ffffff;
            font-weight: 600;
            font-size: calc(1rem * var(--font-scale));
        }

        .compact-score-value {
            color: #00ff88;
            font-weight: bold;
            font-size: calc(1.1rem * var(--font-scale));
        }

        /* Auto-scrolling scores container - 60% of screen height */
        .auto-scroll-container {
            height: 66vh; /* Exactly 60% of screen height */
            overflow: hidden;
            border-radius: calc(10px * var(--scale-factor));
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .auto-scroll-content {
            display: flex;
            flex-direction: column;
            gap: calc(8px * var(--scale-factor));
            padding: calc(10px * var(--scale-factor));
        }

        /* Optimized auto-scroll animation - no hold at top, compressed loop */
        @keyframes autoScrollDown {
            0% {
                transform: translateY(0); /* Start at top */
            }
            17% {
                transform: translateY(0); /* Brief pause at top */
            }
            80% {
                transform: translateY(calc(-100% + 66vh)); /* Scroll to bottom */
            }
            98% {
                transform: translateY(calc(-100% + 66vh)); /* Brief pause at bottom */
            }
            100% {
                transform: translateY(0); /* Fast reset - immediate restart */
            }
        }

        /* Pause animation on hover for better UX */
        .auto-scroll-container:hover .auto-scroll-content {
            animation-play-state: paused;
        }

        /* Top Submitted Answers styling overrides */
        .answers-section .answer-text {
            font-size: calc(1.4rem * var(--font-scale)) !important;
            margin-right: calc(20px * var(--scale-factor)) !important;
            margin-left: 0 !important;
            align-self: flex-start !important;
            text-transform: capitalize !important;
        }

        /* Rank badge designed to work with rounded card corners */
        .answer-rank {
            position: absolute !important;
            top: -2px !important;
            left: -2px !important;
            background: rgba(0, 123, 255, 0.8) !important;
            border: 1px solid rgba(0, 123, 255, 0.6) !important;
            border-radius: 0 0 8px 0 !important;
            padding: 3px 8px !important;
            font-size: 0.75rem !important;
            font-weight: 700 !important;
            color: #ffffff !important;
            text-align: center !important;
            min-width: 32px !important;
            z-index: 10 !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
        }

        .answers-section .answer-card {
            position: relative;
            align-items: flex-start !important;
            padding-top: 0 !important;
            min-height: calc(40px * var(--scale-factor)) !important;
            padding: calc(8px * var(--scale-factor)) calc(12px * var(--scale-factor)) !important;
        }

        .answers-section .answer-count {
            margin-top: calc(8px * var(--scale-factor)) !important;
            font-size: calc(1.1rem * var(--font-scale)) !important;
        }

        .answers-section .answer-points {
            background: transparent !important;
            font-size: calc(1.1rem * var(--font-scale)) !important;
        }

        /* Correct answer badge with proper colors and centering */
        .correct-answer-badge {
            background: rgba(44, 62, 80, 0.9) !important;
            border: 2px solid rgba(52, 73, 94, 0.8) !important;
            border-radius: 10px;
            padding: 8px 15px;
            text-align: center;
            transition: all 0.3s ease;
            width: fit-content;
            max-width: 140px;
            color: #ecf0f1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-height: 40px;
        }

        .correct-answer-badge .correct-answer-text {
            font-size: calc(1.2rem * var(--scale-factor));
            line-height: 1.2;
            margin: 0;
            padding: 0;
            width: 100%;
            display: block;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        /* Dynamic text sizing for correct answer badges */
        .correct-answer-badge[data-answer-length="short"] .correct-answer-text {
            font-size: calc(1.4rem * var(--scale-factor));
        }

        .correct-answer-badge[data-answer-length="medium"] .correct-answer-text {
            font-size: calc(1.2rem * var(--scale-factor));
        }

        .correct-answer-badge[data-answer-length="long"] .correct-answer-text {
            font-size: calc(1rem * var(--scale-factor));
        }

        .correct-answer-badge[data-answer-length="very-long"] .correct-answer-text {
            font-size: calc(0.9rem * var(--scale-factor));
        }

        /* Wrong answers grid - 2 rows */
        .wrong-answers-grid {
            display: grid !important;
            grid-template-rows: repeat(2, 1fr) !important;
            grid-auto-flow: column !important;
            gap: calc(10px * var(--scale-factor)) !important;
            margin: calc(12px * var(--scale-factor)) 0 !important;
        }

        /* Wrong answer card vertical layout */
        .wrong-answer-card {
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            gap: calc(8px * var(--scale-factor)) !important;
            min-height: calc(35px * var(--scale-factor)) !important;
            padding: calc(6px * var(--scale-factor)) calc(10px * var(--scale-factor)) !important;
        }

        .wrong-answer-text {
            font-weight: bold !important;
            margin-bottom: calc(5px * var(--scale-factor)) !important;
            font-size: calc(1rem * var(--font-scale)) !important;
        }

        .wrong-answer-count {
            font-size: calc(0.9rem * var(--font-scale)) !important;
            opacity: 0.8 !important;
        }



        /* Animate sections */
        .answers-section, .correct-not-given-section, .wrong-answers-section {
            opacity: 0;
            transform: translateY(20px);
            animation: sectionSlideIn 0.6s ease-out forwards;
        }

        .answers-section {
            animation-delay: 0.1s;
        }

        .correct-not-given-section {
            animation-delay: 0.3s;
        }

        .wrong-answers-section {
            animation-delay: 0.5s;
        }

        @keyframes sectionSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Answer cards for round results - matching reference image */
        .player-answers-row {
            display: flex;
            gap: calc(8px * var(--scale-factor));
            margin-top: calc(12px * var(--scale-factor));
            justify-content: flex-start;
            width: 100%;
        }

        .answer-card-small {
            background: #2ecc71;
            color: white;
            padding: calc(10px * var(--scale-factor)) calc(12px * var(--scale-factor));
            border-radius: calc(8px * var(--scale-factor));
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            min-height: calc(60px * var(--scale-factor));
            border: none;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            max-width: calc(250px * var(--scale-factor));
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .answer-card-small .answer-text-small {
            font-size: calc(1.2rem * var(--scale-factor));
            line-height: 1.2;
            margin: 0;
            padding: 0;
            width: 100%;
            display: block;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        /* Dynamic text sizing based on answer length */
        .answer-card-small[data-answer-length="short"] .answer-text-small {
            font-size: calc(1.4rem * var(--scale-factor));
        }

        .answer-card-small[data-answer-length="medium"] .answer-text-small {
            font-size: calc(1.2rem * var(--scale-factor));
        }

        .answer-card-small[data-answer-length="long"] .answer-text-small {
            font-size: calc(1rem * var(--scale-factor));
        }

        .answer-card-small[data-answer-length="very-long"] .answer-text-small {
            font-size: calc(0.9rem * var(--scale-factor));
        }

        .answer-card-small.wrong-answer {
            background: #e74c3c;
        }

        .answer-text-small {
            font-size: calc(1.1rem * var(--font-scale));
            font-weight: bold;
            line-height: 1.2;
            margin-bottom: calc(2px * var(--scale-factor));
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            text-align: center;
            width: 100%;
        }

        .answer-points-small {
            font-size: calc(0.9rem * var(--font-scale));
            font-weight: 600;
            opacity: 0.9;
            line-height: 1;
        }

        .no-answers-player {
            color: #95a5a6;
            font-style: italic;
            font-size: calc(0.8rem * var(--font-scale));
            margin-top: calc(10px * var(--scale-factor));
        }

        /* 1920x1080 Grid Width Optimizations */
        .answers-grid, .answers-results-grid, .scores-list, .final-scores-list {
            grid-template-columns: repeat(auto-fit, minmax(calc(400px * var(--scale-factor)), 1fr)) !important;
        }

        .answers-results-grid {
            grid-template-columns: repeat(auto-fit, minmax(calc(450px * var(--scale-factor)), 1fr)) !important;
        }

        .correct-answers-grid {
            display: grid !important;
            grid-template-columns: repeat(auto-fit, minmax(calc(60px * var(--scale-factor)), 1fr)) !important;
            gap: calc(8px * var(--scale-factor)) !important;
            margin: calc(12px * var(--scale-factor)) 0 !important;
        }
        
        .wrong-answers-grid {
            grid-template-columns: repeat(auto-fit, minmax(calc(60px * var(--scale-factor)), 1fr)) !important;
        }

        .top-answers-grid, .incorrect-answers-grid {
            grid-template-columns: repeat(auto-fit, minmax(calc(380px * var(--scale-factor, 0.65)), 1fr)) !important;
        }

        .display-players {
            grid-template-columns: repeat(auto-fit, minmax(calc(140px * var(--scale-factor)), 1fr)) !important;
        }

        /* Reduce font size for submitted answers section headers */
        .answers-section h3,
        .correct-not-given-section h3,
        .wrong-answers-section h3 {
            font-size: calc(1.2rem * var(--font-scale)) !important;
            margin-bottom: calc(8px * var(--scale-factor)) !important;
            margin-top: calc(8px * var(--scale-factor)) !important;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Check if QRCode library loaded
        window.addEventListener('load', function() {
            console.log('üìÑ Page fully loaded at:', new Date().toLocaleTimeString());
            if (typeof QRCode === 'undefined') {
                console.error('QRCode library not loaded!');
            } else {
                console.log('QRCode library loaded successfully');
            }
        });
        
        // Debug: Monitor for any automatic refreshes
        let pageLoadCount = 0;
        window.addEventListener('beforeunload', function() {
            console.log('‚ö†Ô∏è Page unloading at:', new Date().toLocaleTimeString());
        });
        
        // Track page loads
        if (sessionStorage.getItem('pageLoadCount')) {
            pageLoadCount = parseInt(sessionStorage.getItem('pageLoadCount')) + 1;
        } else {
            pageLoadCount = 1;
        }
        sessionStorage.setItem('pageLoadCount', pageLoadCount.toString());
        console.log('üìä Page load count:', pageLoadCount, 'at:', new Date().toLocaleTimeString());
    </script>
</head>
<body>
    <!-- Display Screen (for projector/streaming) -->
    <div id="displayScreen" class="display-mode">
        <!-- Content will be dynamically generated by JavaScript -->
                </div>


        </div>
    </div>

    <script>
        // Display-only JavaScript
        // Old showDisplayScreen function removed - using individual screen functions now

        // Removed updateDisplayScreen function - now using individual screen functions

        function updateDisplayQuestion(question, questionNumber, timer) {
            document.getElementById('displayQuestionNumber').textContent = questionNumber;
            document.getElementById('displayQuestionText').textContent = question;
            document.getElementById('displayTimer').textContent = timer;
        }

        function updateDisplayAnswers(answers) {
            const displayAnswersList = document.getElementById('displayAnswersList');
            displayAnswersList.innerHTML = '';
            
            if (answers && answers.length > 0) {
                // Sort answers by count (most popular first)
                const sortedAnswers = [...answers].sort((a, b) => b.count - a.count);
                
                // Limit display for large answer sets
                const maxAnswers = answers.length > 15 ? 15 : answers.length;
                const displayAnswers = sortedAnswers.slice(0, maxAnswers);
                
                displayAnswers.forEach((answer, index) => {
                    const answerCard = document.createElement('div');
                    answerCard.className = `answer-card ${index < 3 ? 'top-answer' : ''}`;
                    answerCard.innerHTML = `
                        <div class="answer-rank">#${index + 1}</div>
                        <div class="answer-text">${answer.answer}</div>
                        <div class="answer-count">${answer.count} players</div>
                    `;
                    displayAnswersList.appendChild(answerCard);
                });
                
                // Add indicator if there are more answers
                if (answers.length > maxAnswers) {
                    const moreIndicator = document.createElement('div');
                    moreIndicator.className = 'more-answers-indicator';
                    moreIndicator.innerHTML = `
                        <p>... and ${answers.length - maxAnswers} more answers</p>
                    `;
                    displayAnswersList.appendChild(moreIndicator);
                }
            }
        }

        function updateDisplayScoring(answers, scores) {
            const displayAnswersResults = document.getElementById('displayAnswersResults');
            displayAnswersResults.innerHTML = '';
            
            if (answers && answers.length > 0) {
                // Sort answers by points (highest scoring first)
                const sortedAnswers = [...answers].sort((a, b) => b.points - a.points);
                
                // Limit display for large answer sets
                const maxAnswers = answers.length > 12 ? 12 : answers.length;
                const displayAnswers = sortedAnswers.slice(0, maxAnswers);
                
                displayAnswers.forEach((answer, index) => {
                    const answerCard = document.createElement('div');
                    answerCard.className = `answer-card ${answer.correct ? 'correct' : 'incorrect'} ${index < 3 ? 'top-answer' : ''}`;
                    answerCard.innerHTML = `
                        <div class="answer-rank">#${index + 1}</div>
                        <div class="answer-text">${answer.answer}</div>
                        <div class="answer-count">${answer.count} players</div>
                        <div class="answer-points">${answer.points} points</div>
                    `;
                    displayAnswersResults.appendChild(answerCard);
                });
                
                // Add indicator if there are more answers
                if (answers.length > maxAnswers) {
                    const moreIndicator = document.createElement('div');
                    moreIndicator.className = 'more-answers-indicator';
                    moreIndicator.innerHTML = `
                        <p>... and ${answers.length - maxAnswers} more answers</p>
                    `;
                    displayAnswersResults.appendChild(moreIndicator);
                }
            }
            
            const displayCurrentScores = document.getElementById('displayCurrentScores');
            displayCurrentScores.innerHTML = '';
            
            if (scores && scores.length > 0) {
                // Sort by score (highest first)
                const sortedScores = [...scores].sort((a, b) => b.score - a.score);
                
                // Show top 15 players for large groups
                const maxScores = scores.length > 15 ? 15 : scores.length;
                const displayScores = sortedScores.slice(0, maxScores);
                
                displayScores.forEach((score, index) => {
                    const scoreCard = document.createElement('div');
                    scoreCard.className = `score-card ${index < 3 ? 'top-score' : ''}`;
                    scoreCard.innerHTML = `
                        <div class="score-rank">#${index + 1}</div>
                        <div class="player-name">${score.name}</div>
                        <div class="player-score">${score.score} points</div>
                    `;
                    displayCurrentScores.appendChild(scoreCard);
                });
                
                // Add indicator if there are more players
                if (scores.length > maxScores) {
                    const moreIndicator = document.createElement('div');
                    moreIndicator.className = 'more-scores-indicator';
                    moreIndicator.innerHTML = `
                        <p>... and ${scores.length - maxScores} more players</p>
                    `;
                    displayCurrentScores.appendChild(moreIndicator);
                }
            }
        }

        function updateDisplayGameOver(scores) {
            const displayFinalScores = document.getElementById('displayFinalScores');
            displayFinalScores.innerHTML = '';
            
            if (scores && scores.length > 0) {
                // Sort by score (highest first)
                const sortedScores = [...scores].sort((a, b) => b.score - a.score);
                
                // Show top 20 players for large groups
                const maxScores = scores.length > 20 ? 20 : scores.length;
                const displayScores = sortedScores.slice(0, maxScores);
                
                displayScores.forEach((score, index) => {
                    const scoreCard = document.createElement('div');
                    scoreCard.className = `final-score-card ${index === 0 ? 'winner' : ''} ${index < 5 ? 'top-finisher' : ''}`;
                    scoreCard.innerHTML = `
                        <div class="score-rank">#${index + 1}</div>
                        <div class="player-name">${score.name}</div>
                        <div class="player-score">${score.score} points</div>
                        ${index === 0 ? '<div class="winner-badge">üèÜ Winner!</div>' : ''}
                    `;
                    displayFinalScores.appendChild(scoreCard);
                });
                
                // Add indicator if there are more players
                if (scores.length > maxScores) {
                    const moreIndicator = document.createElement('div');
                    moreIndicator.className = 'more-scores-indicator';
                    moreIndicator.innerHTML = `
                        <p>... and ${scores.length - maxScores} more players</p>
                    `;
                    displayFinalScores.appendChild(moreIndicator);
                }
            }
        }

        // Display state management
        let gameState = null;
        let socket = null;
        let lastPlayerCount = 0; // Track player count to detect new additions
        let displayGameCode = null;
        
        function initializeSocket() {
            socket = io();
            
            socket.on('connect', () => {
                console.log('üîå Display connected to server');
                // Request a pairing code so host can attach this display to a game
                try { socket.emit('requestDisplayPairingCode'); } catch (_) {}
                
                // Prefer explicit URL param; do not reuse stale session code
                const urlParams = new URLSearchParams(window.location.search);
                const codeFromUrl = urlParams.get('game');
                if (codeFromUrl) {
                    displayGameCode = codeFromUrl;
                    sessionStorage.setItem('displayGameCode', displayGameCode);
                } else {
                    sessionStorage.removeItem('displayGameCode');
                    displayGameCode = null;
                }
                
                if (displayGameCode) {
                    console.log('üì∫ Display connecting to game:', displayGameCode);
                    // Join the specific game room
                    socket.emit('joinDisplayRoom', { gameCode: displayGameCode });
                } else {
                    console.log('üì∫ No game code specified, showing welcome screen');
                    showIntroScreen();
                }
            });
            socket.on('displayPairingCode', (data) => {
                const code = data?.code || '----';
                window.displayPairingCode = code;
                console.log('üì∫ Display pairing code:', code);
                // If intro screen visible, regenerate QR/text to show pairing code to host/operator
                try { showIntroScreen(); } catch (_) {}
            });
            
            socket.on('disconnect', () => {
                console.log('Display disconnected from server');
                showIntroScreen();
            });
            
            socket.on('connect_error', (error) => {
                console.error('Display connection error:', error);
                showIntroScreen();
            });
            
            socket.on('displayGameState', (gameStateData) => {
                console.log('üìä Display received game state:', gameStateData);
                if (gameStateData) {
                    // Store the game code for future reference
                    if (gameStateData.gameCode) {
                        displayGameCode = gameStateData.gameCode;
                        sessionStorage.setItem('displayGameCode', displayGameCode);
                        // Expose globally so QR builders can include it
                        window.currentGameCode = displayGameCode;
                    }
                    updateDisplayFromGameState(gameStateData);
                } else {
                    // No active game, show welcome screen
                    showIntroScreen();
                }
            });

            socket.on('displayError', (data) => {
                console.error('üì∫ Display error:', data.message);
                showIntroScreen();
            });
            
            socket.on('gameCreated', (gameStateData) => {
                console.log('üéÆ Display: Game created', gameStateData);
                if (gameStateData) {
                    updateDisplayFromGameState(gameStateData);
                } else {
                    showWaitingScreen();
                }
            });
            
            socket.on('gameStarted', (gameStateData) => {
                console.log('Display: Game started');
                updateDisplayFromGameState(gameStateData);
            });
            
            socket.on('nextQuestion', (gameStateData) => {
                console.log('Display: Next question');
                updateDisplayFromGameState(gameStateData);
            });
            
            socket.on('roundComplete', (gameStateData) => {
                console.log('Display: Round complete event received');
                console.log('Display: Game state data:', gameStateData);
                console.log('Display: Game state:', gameStateData.gameState);
                updateDisplayFromGameState(gameStateData);
            });
            
            socket.on('gradingComplete', (gameStateData) => {
                console.log('Display: Grading complete');
                updateDisplayFromGameState(gameStateData);
            });
            
            socket.on('gameFinished', (gameStateData) => {
                console.log('Display: Game finished event received');
                console.log('Display: gameStateData:', gameStateData);
                console.log('Display: gameStateData.gameState:', gameStateData?.gameState);
                console.log('Display: gameStateData.players:', gameStateData?.players);
                
                try {
                    updateDisplayFromGameState(gameStateData);
                    console.log('Display: updateDisplayFromGameState completed successfully');
                } catch (error) {
                    console.error('Display: Error in updateDisplayFromGameState:', error);
                }
            });
            
            socket.on('showOverallLeaderboard', (gameStateData) => {
                console.log('Display: Showing overall leaderboard');
                showOverallLeaderboardScreen(gameStateData);
            });
            
            socket.on('timerUpdate', (data) => {
                console.log('Display: Timer update', data.timeLeft);
                if (gameState && gameState.gameState === 'playing') {
                    updateDisplayTimer(data.timeLeft);
                }
            });
            
            socket.on('playerJoined', (gameStateData) => {
                console.log('Display: Player joined');
                console.log('Display: Received gameStateData:', gameStateData);
                console.log('Display: Players count:', gameStateData.players?.length || 0);
                console.log('Display: Latest players:', gameStateData.players?.slice(-3)?.map(p => p.name) || []);
                updatePlayersOnly(gameStateData);
            });
            
            socket.on('virtualPlayerJoined', (data) => {
                console.log('Display: Virtual player joined', data);
                // Update the game state with the new virtual player
                if (gameState && gameState.players) {
                    // Check if player already exists
                    const existingPlayer = gameState.players.find(p => p.id === data.playerId);
                    if (!existingPlayer) {
                        gameState.players.push({
                            id: data.playerId,
                            name: data.playerName,
                            score: 0,
                            isVirtual: true
                        });
                        console.log(`üé≠ Added virtual player ${data.playerName} to display`);
                        updatePlayersOnly(gameState);
                    }
                }
                
                // Also update the game state if provided
                if (data.gameState) {
                    console.log('Display: Using provided gameState from virtualPlayerJoined');
                    updatePlayersOnly(data.gameState);
                }
            });
            
            socket.on('gameSettingsUpdated', (settings) => {
                console.log('Display: Game settings updated', settings);
                // Update display if needed for settings changes
                if (gameState) {
                    updateDisplayFromGameState(gameState);
                }
            });
            
            socket.on('playerLeft', (gameStateData) => {
                console.log('Display: Player left');
                updatePlayersOnly(gameStateData);
            });
            
            socket.on('answerUpdate', (data) => {
                console.log('Display: Answer update', data);
                console.log('Current game state:', gameState?.gameState);
                console.log('Answers received:', data.answersReceived, 'Total players:', data.totalPlayers);
                
                // Update response indicator for both 'playing' and 'questionActive' states
                if (gameState && (gameState.gameState === 'playing' || gameState.gameState === 'questionActive')) {
                    updateResponseIndicator(data.answersReceived, data.totalPlayers);
                    console.log('‚úÖ Updated response indicator');
                } else {
                    console.log('‚ùå Response indicator not updated - wrong game state:', gameState?.gameState);
                }
            });
            
            socket.on('questionComplete', (gameStateData) => {
                console.log('Display: Question complete - all responses received');
                console.log('Display: Switching to grading mode automatically');
                updateDisplayFromGameState(gameStateData);
            });

            // Auto-generate virtual responses when question starts
            socket.on('questionStarted', (data) => {
                console.log('üé≠ Question started - generating virtual responses');
                if (gameState && gameState.players) {
                    generateVirtualResponsesForDisplay(data.question);
                }
            });
        }

        function updateDisplayFromGameState(newGameState) {
            gameState = newGameState;
            
            if (!gameState) {
                showIntroScreen();
                return;
            }
            
            console.log('üì∫ Updating display with game state:', gameState.gameState);
            console.log('üì∫ Full game state data:', gameState);
            
            switch (gameState.gameState) {
                case 'waiting':
                    console.log('üì∫ Showing waiting screen');
                    showWaitingScreen();
                    break;
                case 'playing':
                    console.log('üì∫ Showing playing screen');
                    showPlayingScreen();
                    break;
                case 'grading':
                    console.log('üì∫ Showing grading screen');
                    showGradingScreen();
                    break;
                case 'scoring':
                    console.log('üì∫ Showing scoring screen');
                    showScoringScreen();
                    break;
                case 'roundComplete':
                    console.log('üì∫ Showing round complete screen');
                    showRoundCompleteScreen();
                    break;
                case 'leaderboard':
                    console.log('üì∫ Showing leaderboard screen');
                    showLeaderboardScreen();
                    break;
                case 'finished':
                    console.log('üì∫ Showing game finished screen');
                    showGameFinishedScreen();
                    break;
                default:
                    console.log('üì∫ Unknown game state, showing intro screen');
                    showIntroScreen();
            }
        }

        // Efficient update function - only updates player grid and count
        function updatePlayersOnly(newGameState) {
            // Always update the global game state
            gameState = newGameState;
            
            // Update player count in header (if we're in waiting state)
            const playerCountElement = document.querySelector('.display-status');
            if (playerCountElement && gameState.gameState === 'waiting') {
                playerCountElement.textContent = `üë• Players: ${gameState.players.length}`;
            }
            
            // Update only the player grid
            const playersContainer = document.querySelector('.display-players');
            if (playersContainer) {
                playersContainer.innerHTML = generatePlayerListDisplay(gameState.players);
            }
            
            console.log(`üì∫ Updated players only: ${gameState.players.length} players`);
            
            // Only do full display update if we're transitioning to a different game state
            // (like from waiting to playing, but not just adding players)
            if (gameState.gameState !== 'waiting') {
                console.log(`üì∫ Game state changed to ${gameState.gameState}, doing full update`);
                updateDisplayFromGameState(gameState);
            }
        }

        function showIntroScreen() {
            preventAllScrolling();
            document.getElementById('displayScreen').innerHTML = `
                <div class="display-content">
                    <div class="display-section">
                        <div class="display-header">
                            <h1 class="display-title">üêë MEGASheep</h1>
                            <p class="display-subtitle">Fleece the competition with ewe-nique answers.<br>Are you a shear genius? Flock around and find out!</p>
                            <p class="display-brand">by Liquid Kourage Entertainment</p>
                        </div>
                        ${displayGameCode ? `
                            <div class="display-status">
                                <p>Connecting to game ${displayGameCode}...</p>
                                <div class="loading-spinner"></div>
                            </div>
                            <div class="qr-code-section">
                                <p class="qr-label">Scan to join the game:</p>
                                <div id="qrCodeIntro" class="qr-code"></div>
                                <p class="game-url">Or go to <strong>megasheep.liquidkourage.com</strong> and enter game code <span class="game-code-highlight">${displayGameCode}</span></p>
                            </div>
                        ` : `
                            <div class="display-status" style="margin-bottom: 8px;">
                                <div class="loading-spinner" style="margin: 0 auto;"></div>
                            </div>
                            <div class="qr-code-section">
                                <div style="font-size:3.2rem;font-weight:900;letter-spacing:0.28em;margin:10px 0;color:#fff;">${((window.displayPairingCode || '----').split('').join(' '))}</div>
                                <p class="game-url" style="color:#ccc;">Host: use this code to connect this display in the host console</p>
                            </div>
                        `}
                    </div>
                </div>
            `;
            
            // Generate QR code after DOM is updated
            setTimeout(() => {
                // Direct join link with game code if available from server via template or later replacement
                const introUrl = window.currentGameCode ? `https://megasheep.liquidkourage.com/?game=${window.currentGameCode}` : 'https://megasheep.liquidkourage.com';
                generateQRCode('qrCodeIntro', introUrl);
            }, 100);
        }

        function preventAllScrolling() {
            // Aggressive scroll prevention - NO SCROLLING EVER
            document.body.style.overflow = 'hidden !important';
            document.documentElement.style.overflow = 'hidden !important';
            document.body.style.height = '100vh';
            document.documentElement.style.height = '100vh';
            document.body.style.width = '100vw';
            document.documentElement.style.width = '100vw';
            document.body.style.margin = '0';
            document.body.style.padding = '0';
            document.documentElement.style.margin = '0';
            document.documentElement.style.padding = '0';
            
            // Prevent any possible overflow on the main container
            const displayScreen = document.getElementById('displayScreen');
            if (displayScreen) {
                displayScreen.style.overflow = 'hidden !important';
                displayScreen.style.height = '100vh';
                displayScreen.style.width = '100vw';
                displayScreen.style.boxSizing = 'border-box';
            }
        }

        function showWaitingScreen() {
            preventAllScrolling();
            document.getElementById('displayScreen').innerHTML = `
                <div class="display-content" style="
                    width: 100vw !important;
                    height: 100vh !important;
                    display: flex !important;
                    flex-direction: column !important;
                    justify-content: space-between !important;
                    align-items: center !important;
                    padding: 0 !important;
                    margin: 0 !important;
                    box-sizing: border-box !important;
                    overflow: hidden !important;
                ">
                    <!-- Top Header -->
                    <div class="display-header" style="
                        width: 100% !important;
                        text-align: center !important;
                        padding: 20px 0 10px 0 !important;
                        flex-shrink: 0 !important;
                        z-index: 1001 !important;
                    ">
                        <h1 class="display-title" style="font-size: 2.5rem !important; margin: 0 0 10px 0 !important;">üéÆ Game Lobby</h1>
                        <p class="display-subtitle" style="font-size: 1.2rem !important; margin: 0 0 5px 0 !important;">Players are joining...</p>
                        <p class="display-status" style="font-size: 1rem !important; margin: 0 !important;">üë• Players: ${gameState.players.length}</p>
                        </div>
                    
                    <!-- Players Grid (will position itself) -->
                    <div class="display-players" style="
                        flex: 1 !important; 
                        position: relative !important;
                        width: 100% !important;
                        overflow: hidden !important;
                        display: flex !important;
                        justify-content: center !important;
                        align-items: center !important;
                        box-sizing: border-box !important;
                    ">
                            ${generatePlayerListDisplay(gameState.players)}
                        </div>
                    
                    <!-- Bottom QR Code -->
                    <div class="qr-code-section" style="
                        width: 100% !important;
                        text-align: center !important;
                        padding: 10px 0 20px 0 !important;
                        flex-shrink: 0 !important;
                        z-index: 1001 !important;
                        background: rgba(0, 0, 0, 0.4) !important;
                        backdrop-filter: blur(8px) !important;
                    ">
                        <p class="qr-label" style="font-size: 0.9rem !important; margin: 0 0 8px 0 !important;">Scan to join:</p>
                        <div id="qrCodeWaiting" class="qr-code" style="display: inline-block !important;"></div>
                        <p class="game-url" style="font-size: 1rem !important; margin: 8px 0 0 0 !important;">Or go to <strong>megasheep.liquidkourage.com</strong> and enter game code <span class="game-code-highlight">${displayGameCode || 'XXXX'}</span></p>
                    </div>
                </div>
            `;
            
            // Generate QR code after DOM is updated
            setTimeout(() => {
                const waitingUrl = window.currentGameCode ? `https://megasheep.liquidkourage.com/?game=${window.currentGameCode}` : 'https://megasheep.liquidkourage.com';
                generateQRCode('qrCodeWaiting', waitingUrl);
            }, 100);
        }

        function showPlayingScreen() {
            const currentQuestion = gameState.questions[gameState.currentQuestion];
            const questionNumber = gameState.currentQuestion + 1;
            const roundNumber = Math.ceil(questionNumber / gameState.questionsPerRound);
            const questionInRound = ((questionNumber - 1) % gameState.questionsPerRound) + 1;
            
            document.getElementById('displayScreen').innerHTML = `
                <div class="playing-container">
                    <!-- Timer - Upper Right -->
                        <div class="timer-display">
                        <div class="timer-circle" id="timerCircle">
                            <span class="timer-text" id="displayTimer">${gameState.timeLeft || 30}</span>
                            </div>
                        </div>
                    
                    <!-- Round/Question Info - Top Center -->
                    <div class="round-info">
                        <h2>Round ${roundNumber} ‚Ä¢ Question ${questionInRound}/${gameState.questionsPerRound}</h2>
                    </div>
                    
                    <!-- Question Card -->
                    <div class="question-content">
                        <div class="question-card">
                        <h1 class="question-prompt">${currentQuestion ? currentQuestion.prompt : 'Loading question...'}</h1>
                        </div>
                    </div>
                    
                    <!-- Response Progress Indicator -->
                    <div class="response-indicator" id="responseIndicator">
                        <div class="response-progress">
                            <div class="response-bar" id="responseBar"></div>
                        </div>
                        <div class="response-text" id="responseText">
                            <span id="responseCount">0</span> of <span id="totalPlayerCount">${gameState.players.length}</span> responses
                        </div>
                    </div>
                </div>
            `;
            
            // Set initial timer state
            updateDisplayTimer(gameState.timeLeft || 30);
            
            // Initialize response indicator with actual response count if available
            const actualResponseCount = gameState.currentAnswerGroups ? 
                gameState.currentAnswerGroups.reduce((total, group) => total + (group.count || 0), 0) : 0;
            const fallbackResponseCount = gameState.answersReceived || actualResponseCount || 0;
            
            console.log('üîç Response count calculation:');
            console.log('  - gameState.answersReceived:', gameState.answersReceived);
            console.log('  - actualResponseCount from answer groups:', actualResponseCount);
            console.log('  - Using fallback count:', fallbackResponseCount);
            
            updateResponseIndicator(fallbackResponseCount, gameState.players.length);
            
            // Auto-generate virtual responses when playing screen loads
            console.log('üé≠ Playing screen loaded - triggering virtual responses');
            if (currentQuestion && gameState.players) {
                // Delay slightly to ensure screen is fully loaded
                setTimeout(() => {
                    generateVirtualResponsesForDisplay(currentQuestion);
                }, 1000);
            }
        }
        
        function updateDisplayTimer(timeLeft) {
            const timerText = document.getElementById('displayTimer');
            const timerCircle = document.getElementById('timerCircle');
            
            if (!timerText || !timerCircle) return;
            
            // Add tick animation for countdown effect
            timerText.classList.add('tick');
            setTimeout(() => timerText.classList.remove('tick'), 300);
            
            // Update timer display
            timerText.textContent = timeLeft;
            
            // Remove existing timer classes
            timerCircle.classList.remove('urgent', 'warning');
            
            // Add appropriate class based on time remaining
            if (timeLeft <= 5) {
                timerCircle.classList.add('urgent');
            } else if (timeLeft <= 10) {
                timerCircle.classList.add('warning');
            }
            
            // Update gameState for consistency
            if (gameState) {
                gameState.timeLeft = timeLeft;
            }
        }
        
        function updateResponseIndicator(responses, totalPlayers) {
            const responseCount = document.getElementById('responseCount');
            const totalPlayerCount = document.getElementById('totalPlayerCount');
            const responseBar = document.getElementById('responseBar');
            
            if (!responseCount || !totalPlayerCount || !responseBar) return;
            
            // Update text
            responseCount.textContent = responses;
            totalPlayerCount.textContent = totalPlayers;
            
            // Update progress bar
            const percentage = totalPlayers > 0 ? (responses / totalPlayers) * 100 : 0;
            responseBar.style.width = `${percentage}%`;
            
            // Add completion pulse when all responses are in
            if (responses === totalPlayers && totalPlayers > 0) {
                responseBar.style.background = 'linear-gradient(90deg, #2ecc71 0%, #27ae60 100%)';
                responseBar.style.boxShadow = '0 0 15px rgba(46, 204, 113, 0.6)';
            } else {
                responseBar.style.background = 'linear-gradient(90deg, #3498db 0%, #2ecc71 100%)';
                responseBar.style.boxShadow = 'none';
            }
        }

        function showGradingScreen() {
            document.getElementById('displayScreen').innerHTML = `
                <div class="grading-container">
                    <div class="grading-header">
                        <h1>üìù Host Grading in Progress</h1>
                        <p class="grading-subtitle">Please wait while answers are being reviewed</p>
                    </div>
                    
                    <div class="grading-content">
                        <div class="grading-animation">
                            <div class="grading-spinner"></div>
                            <h3>üéØ Categorizing Answers</h3>
                            <p>The host is reviewing and grouping similar responses</p>
                            <p>This ensures fair and accurate scoring</p>
                        </div>
                        
                        <div class="grading-stats">
                            <div class="stat-box">
                                <span class="stat-number">${gameState.answers ? Object.keys(gameState.answers).length : gameState.players?.length || 0}</span>
                                <span class="stat-label">Responses Received</span>
                            </div>
                            <div class="stat-box">
                                <span class="stat-number">${gameState.players?.length || 0}</span>
                                <span class="stat-label">Players</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="grading-message">
                        <p>‚ú® Results will appear shortly after grading is complete</p>
                    </div>
                </div>
            `;
        }

        function showScoringScreen() {
            // Get the correct and wrong answers for this question
            const { submittedAnswers, correctNotGiven, wrongAnswers } = categorizeAnswersForDisplay();
            
            document.getElementById('displayScreen').innerHTML = `
                <div class="display-main-container">
                    <!-- Left Column: Question Results (75%) -->
                    <div class="question-results-section">
                        <div class="scoring-header">
                            <h1>üìä Question Results</h1>
                            <p class="scoring-subtitle">${gameState.currentQuestionData?.prompt || 'Answer Breakdown'}</p>
                        </div>
                        
                        <div class="scoring-content">
                            <!-- Top Submitted Answers -->
                            <div class="answers-section">
                                <h3>üèÜ Top Submitted Answers</h3>
                                ${generateTopAnswersDisplay(submittedAnswers)}
                            </div>
                            
                            <!-- Correct Answers Not Given -->
                            <div class="correct-not-given-section">
                                <h3>‚úÖ Correct Answers Not Given</h3>
                                ${generateCorrectNotGivenDisplay(correctNotGiven)}
                            </div>
                            
                            <!-- Wrong Answers Submitted -->
                            <div class="wrong-answers-section">
                                <h3>‚ùå Wrong Answers Submitted</h3>
                                ${generateWrongAnswersDisplay(wrongAnswers)}
                            </div>
                        </div>
                        
                        <div class="scoring-navigation">
                            <p>Next question starting soon...</p>
                        </div>
                    </div>
                    
                    <!-- Right Column: Current Scores (25%) -->
                    <div class="current-scores-section">
                        <div class="scores-header">
                            <h1>üìà Current Scores</h1>
                            <p class="scoring-subtitle">Round ${Math.ceil((gameState.currentQuestion + 1) / gameState.questionsPerRound)}/5 ‚Ä¢ Question ${((gameState.currentQuestion) % gameState.questionsPerRound) + 1} of 5</p>
                        </div>
                        
                        <div class="scores-content">
                            ${generateCompactScoresDisplay(gameState.players)}
                        </div>
                    </div>
                </div>
            `;
        }

        function generatePlayerListDisplay(players) {
            if (!players || players.length === 0) {
                lastPlayerCount = 0; // Reset when no players
                return '<p>No players yet...</p>';
            }
            
            // Simple grid calculation - aim for roughly square, optimized for perfect fit
            const totalPlayers = players.length;
            
            // SMART GRID: Calculate optimal cols/rows based on available space and card aspect ratio
            let cols, rows;
            
            // Get green container dimensions first for smarter calculation
            const greenContainer = document.querySelector('.display-players');
            const greenRect = greenContainer ? greenContainer.getBoundingClientRect() : {
                width: window.innerWidth * 0.8,
                height: window.innerHeight * 0.6
            };
            
            const parentPadding = 20;
            const parentMargin = 10;
            const parentBorder = 4;
            const gap = 8;
            
            // Available space inside yellow container - MAX 80% of screen width
            const maxScreenWidth = window.innerWidth * 0.8; // 80% constraint
            const maxYellowWidth = Math.min(
                greenRect.width - (parentMargin * 2) - parentBorder,
                maxScreenWidth
            );
            const maxYellowHeight = greenRect.height - (parentMargin * 2) - parentBorder;
            const availableWidth = maxYellowWidth - (parentPadding * 2);
            const availableHeight = maxYellowHeight - (parentPadding * 2);
            
            // Card aspect ratio is 1.6:1 (width:height)
            const cardAspectRatio = 1.6;
            
            // SPECIAL LOGIC FOR FIRST 20 CARDS: More balanced layouts
            let bestCols = Math.ceil(Math.sqrt(totalPlayers));
            let bestCardSize = 0;
            
            // For small groups (‚â§20), prefer more balanced/square layouts
            let minCols, maxCols;
            if (totalPlayers <= 20) {
                // Special handling for very small groups
                if (totalPlayers <= 6) {
                    // Force minimum 2 columns for tiny groups
                    minCols = 2;
                    maxCols = Math.max(3, bestCols + 1);
                    console.log(`üìä Tiny group optimization: forcing ${minCols}-${maxCols} columns for ${totalPlayers} players`);
                } else if (totalPlayers >= 7 && totalPlayers <= 12) {
                    // Special fixes for problematic counts 7-12
                    if (totalPlayers === 7 || totalPlayers === 8) {
                        // Force 4x2 layout instead of 2x4
                        minCols = 4;
                        maxCols = 4;
                        console.log(`üìä Fixed layout for ${totalPlayers} players: forcing 4 columns`);
                    } else if (totalPlayers === 9) {
                        // Force 3x3 layout
                        minCols = 3;
                        maxCols = 3;
                        console.log(`üìä Fixed layout for ${totalPlayers} players: forcing 3x3 square`);
                    } else if (totalPlayers >= 10 && totalPlayers <= 12) {
                        // Force 4 columns for 3x4 layout (3 rows, 4 columns)
                        minCols = 4;
                        maxCols = 4;
                        console.log(`üìä Fixed layout for ${totalPlayers} players: forcing 4 columns for 3x4 layout`);
                    }
                } else {
                    // Prefer balanced layouts for other small groups
                    minCols = Math.max(2, bestCols - 2); // Ensure at least 2 columns
                    maxCols = bestCols + 2;
                    console.log(`üìä Small group optimization: testing ${minCols}-${maxCols} columns for ${totalPlayers} players`);
                }
            } else {
                // Normal range for larger groups
                minCols = Math.max(1, bestCols - 3);
                maxCols = bestCols + 8;
            }
            
            for (let testCols = minCols; testCols <= maxCols; testCols++) {
                const testRows = Math.ceil(totalPlayers / testCols);
                
                // Calculate maximum card size for this grid
                const maxCardWidth = (availableWidth - (gap * (testCols - 1))) / testCols;
                const maxCardHeight = (availableHeight - (gap * (testRows - 1))) / testRows;
                
                // Respect aspect ratio - card width should be 1.6 * card height
                const cardWidthByRatio = maxCardHeight * cardAspectRatio;
                const cardHeightByRatio = maxCardWidth / cardAspectRatio;
                
                // Use the limiting dimension
                const finalCardWidth = Math.min(maxCardWidth, cardWidthByRatio);
                const finalCardHeight = Math.min(maxCardHeight, cardHeightByRatio);
                
                const cardArea = finalCardWidth * finalCardHeight;
                
                // Track the configuration that gives the largest cards
                // NEW LIMITS: Min 120x75, Max 320x200
                // PREFER VERTICAL EXPANSION: When card sizes are similar, prefer taller layouts
                if (finalCardWidth >= 120 && finalCardHeight >= 75 &&
                    finalCardWidth <= 320 && finalCardHeight <= 200) {
                    
                    const isCurrentBetter = cardArea > bestCardSize;
                    const isSimilarSize = bestCardSize > 0 && Math.abs(cardArea - bestCardSize) < (bestCardSize * 0.05); // Within 5%
                    
                    let shouldUpdate = isCurrentBetter;
                    
                    // Special logic for small groups (‚â§20): prefer square grids
                    if (totalPlayers <= 20 && isSimilarSize) {
                        const currentDiff = Math.abs(testCols - testRows); // How far from square
                        const bestDiff = bestCardSize > 0 ? Math.abs(cols - rows) : 999;
                        
                        // Prefer the layout closer to square (cols ‚âà rows)
                        if (currentDiff < bestDiff) {
                            shouldUpdate = true;
                            console.log(`üìê More square: ${testCols}x${testRows} (diff ${currentDiff}) vs ${cols}x${rows} (diff ${bestDiff})`);
                        }
                    } else if (totalPlayers > 20 && isSimilarSize) {
                        // For larger groups, prefer vertical expansion
                        const isTaller = testRows > rows;
                        if (isTaller) {
                            shouldUpdate = true;
                        }
                    }
                    
                    if (shouldUpdate) {
                        bestCardSize = cardArea;
                        cols = testCols;
                        rows = testRows;
                    }
                }
            }
            
            // Fallback if no valid horizontal layout found
            if (bestCardSize === 0) {
                console.log(`‚ö†Ô∏è No horizontal layout found, using square fallback`);
                cols = Math.ceil(Math.sqrt(totalPlayers));
                rows = Math.ceil(totalPlayers / cols);
                bestCardSize = 1; // Ensure we proceed
            }
            
            console.log(`üéØ SMART GRID: ${cols}x${rows} for ${totalPlayers} players (${totalPlayers <= 20 ? 'prefer square' : 'vertical expansion'}, max 80% width)`);
            
            // Calculate optimal card size for the chosen grid
            const maxCardWidth = (availableWidth - (gap * (cols - 1))) / cols;
            const maxCardHeight = (availableHeight - (gap * (rows - 1))) / rows;
            
            // Respect aspect ratio
            const cardWidthByRatio = maxCardHeight * cardAspectRatio;
            const cardHeightByRatio = maxCardWidth / cardAspectRatio;
            
            // Use the limiting dimension
            let cardWidth = Math.min(maxCardWidth, cardWidthByRatio);
            let cardHeight = Math.min(maxCardHeight, cardHeightByRatio);
            
            // Enforce size limits: Min 120x75, Max 320x200
            cardWidth = Math.min(320, Math.max(120, cardWidth));
            cardHeight = Math.min(200, Math.max(75, cardHeight));
            
            console.log(`üñ•Ô∏è Screen: ${window.innerWidth}x${window.innerHeight}, Available: ${availableWidth}x${availableHeight}`);
            console.log(`üìä Target grid: ${cols}x${rows} = ${totalPlayers} players`);
            
            // Keep reducing card size until grid fits
            let attempts = 0;
            while (attempts < 20) {
                const gridWidth = (cardWidth * cols) + (gap * (cols - 1));
                const gridHeight = (cardHeight * rows) + (gap * (rows - 1));
                
                console.log(`   Attempt ${attempts + 1}: Cards ${cardWidth}x${cardHeight}, Grid ${gridWidth}x${gridHeight}`);
                
                if (gridWidth <= availableWidth && gridHeight <= availableHeight) {
                    console.log(`‚úÖ SUCCESS: Grid fits in available space`);
                    break;
                }
                
                // Reduce card size by 10px and maintain aspect ratio
                cardWidth -= 10;
                cardHeight = Math.round(cardWidth / 1.6);
                attempts++;
            }
            
            if (attempts >= 20) {
                console.error(`üö® EMERGENCY: Using minimum card size`);
                cardWidth = 60;
                cardHeight = 37;
            }
            
            let finalGridWidth = (cardWidth * cols) + (gap * (cols - 1));
            let finalGridHeight = (cardHeight * rows) + (gap * (rows - 1));
            
            // HARD STOP: If yellow would overflow green, force emergency reduction
            const finalYellowWidth = finalGridWidth + (parentPadding * 2);
            const finalYellowHeight = finalGridHeight + (parentPadding * 2);
            
            if (finalYellowWidth > maxYellowWidth || finalYellowHeight > maxYellowHeight) {
                console.error(`üö® EMERGENCY OVERRIDE: Yellow ${finalYellowWidth}x${finalYellowHeight} > Green ${maxYellowWidth}x${maxYellowHeight}`);
                
                // Force cards to be tiny if needed to fit
                const maxCardWidth = Math.floor((maxYellowWidth - (parentPadding * 2) - (gap * (cols - 1))) / cols);
                const maxCardHeight = Math.floor((maxYellowHeight - (parentPadding * 2) - (gap * (rows - 1))) / rows);
                
                cardWidth = Math.max(120, maxCardWidth);  // Minimum 120px wide
                cardHeight = Math.max(75, maxCardHeight); // Minimum 75px tall
                
                console.log(`üîí HARD STOP: Forced cards to ${cardWidth}x${cardHeight}`);
                
                // Recalculate with forced dimensions
                finalGridWidth = (cardWidth * cols) + (gap * (cols - 1));
                finalGridHeight = (cardHeight * rows) + (gap * (rows - 1));
            }
            
            console.log(`üéØ FINAL: Cards ${cardWidth}x${cardHeight}, Grid ${finalGridWidth}x${finalGridHeight}`);
            
            let html = `
                <div class="parent-container" style="
                    padding: 20px;
                    margin: 10px auto;
                    border-radius: 8px;
                    display: inline-block;
                ">
                <div class="stable-players-grid" style="
                    display: grid;
                    grid-template-rows: repeat(${rows}, ${cardHeight}px);
                    grid-auto-flow: column;
                    gap: ${gap}px;
                    height: ${finalGridHeight}px;
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                ">
            `;
            
            // Detect if this is a re-render with new players
            const isNewPlayerAdded = players.length > lastPlayerCount;
            
            // If players left, reset the counter to re-enable animations
            if (players.length < lastPlayerCount) {
                lastPlayerCount = 0;
            }
            
            players.forEach((player, index) => {
                // Determine special classes
                let specialClasses = '';
                if (player.isHost) {
                    specialClasses += ' host-player';
                }
                
                // Only animate new cards (those added beyond the last count)
                const isNewCard = index >= lastPlayerCount;
                const animationDelay = isNewCard ? ((index - lastPlayerCount) % 20) * 50 : 0;
                
                html += `
                    <div class="modern-player-card${specialClasses}" style="
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                        align-items: center;
                        padding: 8px 6px;
                        background: linear-gradient(135deg, rgba(0, 123, 255, 0.2), rgba(0, 86, 179, 0.15));
                        border: 2px solid rgba(0, 123, 255, 0.4);
                        border-radius: 12px;
                        aspect-ratio: 1.6/1;
                        box-sizing: border-box;
                        text-align: center;
                        backdrop-filter: blur(10px);
                        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                        position: relative;
                        overflow: hidden;
                        box-shadow: 0 4px 15px rgba(0, 123, 255, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
                        ${isNewCard ? `
                            animation: cardSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
                            animation-delay: ${animationDelay}ms;
                            transform: translateY(30px) scale(0.8);
                            opacity: 0;
                            animation-fill-mode: forwards;
                        ` : `
                            transform: translateY(0) scale(1);
                            opacity: 1;
                        `}
                    ">
                        <span class="modern-player-name">${player.name}</span>
                    </div>
                `;
            });
            
            html += '</div>'; // Close stable-players-grid
            html += '</div>'; // Close parent-container
            
            // Update player count tracking
            lastPlayerCount = players.length;
            
            // Add auto-scroll if there are many players
            if (players.length > 12) {
                setTimeout(() => {
                    const gridContainer = document.querySelector('.stable-players-grid');
                    if (gridContainer) {
                        gridContainer.style.overflow = 'hidden';
                        const content = gridContainer.querySelector('.auto-scroll-content') || gridContainer;
                        content.style.animation = `autoScrollDown ${Math.max(players.length * 0.5, 8)}s ease-in-out infinite`;
                    }
                }, 1000);
            }
            
            return html;
        }

        function generateAnswersDisplay(answerGroups) {
            if (!answerGroups || answerGroups.length === 0) {
                return '<p>No answers submitted.</p>';
            }
            
            const displayCount = answerGroups.length <= 15 ? answerGroups.length : 15;
            const answersToShow = answerGroups.slice(0, displayCount);
            
            let html = '<div class="answers-grid">';
            
            answersToShow.forEach((group, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                html += `
                    <div class="answer-card ${rankClass}">
                        <div class="answer-rank">#${index + 1}</div>
                        <div class="answer-text">${group.answer}</div>
                        <div class="answer-stats">
                            <span class="answer-count">${group.count} players</span>
                            <span class="answer-points">${group.points} pts</span>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            if (answerGroups.length > 15) {
                html += `<div class="more-answers-indicator">And ${answerGroups.length - 15} more answers...</div>`;
            }
            
            return html;
        }

        function generateCompactScoresDisplay(players) {
            if (!players || players.length === 0) {
                return '<p style="color: #cccccc; text-align: center;">No players yet</p>';
            }
            
            // Sort players by score (highest first)
            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
            
            // If 20 or fewer players, show all without scrolling
            if (sortedPlayers.length <= 20) {
                let html = '<div class="compact-scores-list">';
                sortedPlayers.forEach((player, index) => {
                    const rankEmoji = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                    html += `
                        <div class="compact-score-item">
                            <div class="compact-score-name">
                                <span style="margin-right: 8px;">${rankEmoji}</span>
                                ${player.name}
                            </div>
                            <div class="compact-score-value">${player.score}</div>
                        </div>
                    `;
                });
                html += '</div>';
                return html;
            }
            
            // For more than 20 players, create auto-scrolling list
            const scrollId = `scroll-scores-${Date.now()}`;
            let html = `<div class="auto-scroll-container" id="${scrollId}">`;
            html += '<div class="auto-scroll-content">';
            
            // Create the scrolling content - just one list (no duplication needed)
            sortedPlayers.forEach((player, index) => {
                const rankEmoji = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                html += `
                    <div class="compact-score-item">
                        <div class="compact-score-name">
                            <span style="margin-right: 8px;">${rankEmoji}</span>
                            ${player.name}
                        </div>
                        <div class="compact-score-value">${player.score}</div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            
            // Add scroll indicator
            html += `<div style="text-align: center; color: #cccccc; margin-top: 10px; font-size: 0.9rem;">
                üìã Cycling through all ${sortedPlayers.length} players
            </div>`;
            
            // Start auto-scroll after a delay
            setTimeout(() => {
                startAutoScroll(scrollId, sortedPlayers.length);
            }, 1000);
            
            return html;
        }

        function generateVirtualResponsesForDisplay(question) {
            if (!gameState || !gameState.players) return;
            
            console.log('üé≠ Generating virtual responses for display');
            
            // Get virtual players only
            const virtualPlayers = gameState.players.filter(p => p.isVirtual);
            console.log(`üé≠ Found ${virtualPlayers.length} virtual players to generate responses for`);
            
            if (virtualPlayers.length === 0) {
                console.log('üé≠ No virtual players found');
                return;
            }
            
            // Get correct answers for this question
            const correctAnswers = question.correct_answers || [];
            const questionText = question.prompt || 'Unknown question';
            
            console.log(`üé≠ Question: "${questionText}"`);
            console.log(`üé≠ Correct answers:`, correctAnswers);
            
            // Generate responses for each virtual player
            virtualPlayers.forEach((player, index) => {
                // Simulate response time (0.5 to 3 seconds)
                const responseDelay = 500 + Math.random() * 2500;
                
                setTimeout(() => {
                    let response;
                    let isCorrect;
                    
                    // 75% correct answers, 25% incorrect
                    if (Math.random() < 0.75 && correctAnswers.length > 0) {
                        response = correctAnswers[Math.floor(Math.random() * correctAnswers.length)];
                        isCorrect = true;
                    } else {
                        // Generate incorrect answers based on question type
                        const incorrectAnswers = [
                            'I don\'t know',
                            'Maybe',
                            'Not sure', 
                            'Could be',
                            'Possibly',
                            'I think so',
                            'Probably not',
                            'Definitely not',
                            'No idea',
                            'Unsure'
                        ];
                        response = incorrectAnswers[Math.floor(Math.random() * incorrectAnswers.length)];
                        isCorrect = false;
                    }
                    
                    // 20% of correct answers should be modified for manual grading practice
                    if (isCorrect && Math.random() < 0.2) {
                        response = modifyAnswerForGrading(response);
                    }
                    
                    console.log(`üé≠ Virtual player ${player.name} answered: "${response}" (${isCorrect ? 'correct' : 'incorrect'})`);
                    
                    // Emit the virtual response via socket
                    if (socket) {
                        socket.emit('virtualAnswerSubmitted', {
                            gameCode: gameState.gameCode,
                            playerId: player.id,
                            playerName: player.name,
                            answer: response,
                            isCorrect: isCorrect
                        });
                    }
                    
                }, responseDelay);
            });
        }

        function modifyAnswerForGrading(answer) {
            // Add slight variations to correct answers for manual grading practice
            const variations = [
                answer + '!',
                answer + '?',
                answer + '...',
                answer + ' (I think)',
                answer + ' maybe',
                answer.toLowerCase(),
                answer.toUpperCase(),
                answer.charAt(0).toUpperCase() + answer.slice(1).toLowerCase()
            ];
            return variations[Math.floor(Math.random() * variations.length)];
        }

        function startAutoScroll(scrollId, playerCount) {
            const container = document.getElementById(scrollId);
            if (!container) return;
            
            const content = container.querySelector('.auto-scroll-content');
            if (!content) return;
            
            // Calculate cycle time: 1.5x faster across the board
            // About 2 seconds per player visible, minimum 10 seconds total
            const baseTime = Math.max(playerCount * 1.0, 10);
            const totalCycleTime = baseTime / 1.5; // 1.5x speed increase
            
            // Start the scroll animation - down, pause, reset
            content.style.animation = `autoScrollDown ${totalCycleTime}s ease-in-out infinite`;
            
            console.log(`üîÑ Started auto-scroll for ${playerCount} players, cycle time: ${totalCycleTime}s (1.5x faster)`);
        }

        function generateScoresDisplay(players) {
            if (!players || players.length === 0) {
                return '<p>No players yet.</p>';
            }
            
            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
            const displayCount = players.length <= 20 ? players.length : 20;
            const playersToShow = sortedPlayers.slice(0, displayCount);
            
            let html = '<div class="scores-list">';
            
            playersToShow.forEach((player, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                html += `
                    <div class="score-entry ${rankClass}">
                        <div class="score-rank">#${index + 1}</div>
                        <div class="score-name">${player.name}</div>
                        <div class="score-points">${player.score} pts</div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            if (players.length > 20) {
                html += `<div class="more-scores-indicator">And ${players.length - 20} more players...</div>`;
            }
            
            return html;
        }

        function showRoundCompleteScreen() {
            const roundHistory = gameState.roundHistory;
            const currentRoundData = roundHistory[roundHistory.length - 1];
            const currentRound = currentRoundData.roundNumber; // Use the actual round number from the round data
            
            const playerCount = gameState.players.length;
            
            // Determine column layout based on player count
            let columnClass = 'leaderboard-single-column';
            if (playerCount > 20) {
                columnClass = 'leaderboard-three-column';
            } else if (playerCount > 10) {
                columnClass = 'leaderboard-two-column';
            }
            
            document.getElementById('displayScreen').innerHTML = `
                <div class="round-leaderboard-container ${columnClass}">
                    <div class="round-leaderboard-header">
                        <h1>üéØ Round ${currentRound} Complete!</h1>
                        <p class="round-subtitle">Round ${currentRound} Scores ‚Ä¢ Questions ${currentRoundData.questionStart} - ${currentRoundData.questionEnd} ‚Ä¢ ${gameState.players.length} Players</p>
                    </div>
                    
                    <div class="round-leaderboard-content" id="roundLeaderboardContent">
                        <div class="auto-scroll-content">
                            ${generateAdvancedRoundDisplay(currentRoundData, columnClass)}
                        </div>
                    </div>
                </div>
            `;
            
            // Set up auto-scrolling for the round leaderboard
            setTimeout(() => {
                const content = document.getElementById('roundLeaderboardContent');
                if (content && content.scrollHeight > content.clientHeight) {
                    startAutoScroll('roundLeaderboardContent', gameState.players.length);
                }
            }, 100);
        }

        function showLeaderboardScreen() {
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            
            document.getElementById('displayScreen').innerHTML = `
                <div class="display-content">
                    <div class="display-section">
                        <div class="display-header">
                            <h1 class="display-title">üèÜ Overall Leaderboard</h1>
                            <p class="display-subtitle">Final Standings</p>
                            <p class="display-brand">by Liquid Kourage Entertainment</p>
                    </div>
                    
                    <div class="leaderboard-content">
                        ${generateLeaderboardDisplay(sortedPlayers)}
                    </div>
                    
                    <div class="leaderboard-navigation">
                        <button onclick="showRoundHistory()" class="btn btn-secondary">View Round History</button>
                        <button onclick="showIntroScreen()" class="btn btn-primary">Back to Intro</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function showGameFinishedScreen() {
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            const winner = sortedPlayers[0];
            
            document.getElementById('displayScreen').innerHTML = `
                <div class="display-content">
                    <div class="display-section">
                        <div class="display-header">
                            <h1 class="display-title">üéâ Game Complete!</h1>
                            <p class="display-subtitle">Final Results</p>
                            <p class="display-brand">by Liquid Kourage Entertainment</p>
                        </div>
                        
                    <div class="winner-announcement">
                        <div class="winner-card">
                            <h2>üèÜ Winner: ${winner.name}</h2>
                            <p class="winner-score">Final Score: ${winner.score} points</p>
                        </div>
                    </div>
                    
                    <div class="final-leaderboard">
                        <h3>üìä Final Standings</h3>
                        ${generateLeaderboardDisplay(sortedPlayers)}
                    </div>
                    
                    <div class="game-navigation">
                        <button onclick="showRoundHistory()" class="btn btn-secondary">View Round History</button>
                        <button onclick="showIntroScreen()" class="btn btn-primary">Play Again</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function showOverallLeaderboardScreen(gameStateData) {
            updateDisplayFromGameState(gameStateData);
            
            const roundHistory = gameState.roundHistory || [];
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);
            
            // Determine column layout based on player count
            const playerCount = gameState.players.length;
            let columnClass = '';
            if (playerCount <= 3) columnClass = 'three-columns';
            else if (playerCount <= 6) columnClass = 'four-columns';
            else if (playerCount <= 10) columnClass = 'five-columns';
            else columnClass = 'six-columns';
            
            document.getElementById('displayScreen').innerHTML = `
                <div class="round-leaderboard-container ${columnClass}">
                    <div class="round-leaderboard-header">
                        <h1>üèÜ Overall Leaderboard</h1>
                        <p class="round-subtitle">Cumulative Scores ‚Ä¢ ${gameState.players.length} Players</p>
                    </div>
                    
                    <div class="round-leaderboard-content" id="roundLeaderboardContent">
                        ${generateOverallLeaderboardDisplay(sortedPlayers, roundHistory)}
                    </div>
                </div>
            `;
            
            // Start auto-scroll for the leaderboard
            startAutoScroll('roundLeaderboardContent');
        }
        
        function generateOverallLeaderboardDisplay(sortedPlayers, roundHistory) {
            let html = '';
            
            sortedPlayers.forEach((player, playerIndex) => {
                const rankClass = playerIndex < 3 ? `rank-${playerIndex + 1}` : '';
                const playerRounds = generatePlayerRoundsDisplay(player, roundHistory);
                
                html += `
                    <div class="player-card ${rankClass}">
                        <div class="player-header">
                            <div class="player-rank">#${playerIndex + 1}</div>
                            <div class="player-name">${player.name}</div>
                            <div class="player-total-score">${player.score} pts</div>
                        </div>
                        <div class="player-answers-container">
                            ${playerRounds}
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function generatePlayerRoundsDisplay(player, roundHistory) {
            let html = '<div class="player-answers-row">';
            
            roundHistory.forEach((roundData, index) => {
                // Find this player's score for this round
                const playerRoundData = roundData.players.find(p => p.name === player.name);
                const roundScore = playerRoundData ? playerRoundData.score : 0;
                const roundNumber = roundData.roundNumber;
                
                // Determine text size based on round number length
                let textSizeClass = 'medium';
                if (roundNumber <= 9) {
                    textSizeClass = 'short';
                } else if (roundNumber <= 99) {
                    textSizeClass = 'medium';
                } else {
                    textSizeClass = 'long';
                }
                
                html += `
                    <div class="answer-card-small correct" data-answer-length="${textSizeClass}">
                        <span class="answer-text-small">Round ${roundNumber}</span>
                        <span class="answer-points-small">${roundScore}</span>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }

        function generateRoundAnswersDisplay(answerGroups) {
            if (!answerGroups || answerGroups.length === 0) {
                return '<p>No answers submitted this round.</p>';
            }
            
            const displayCount = answerGroups.length <= 15 ? answerGroups.length : 15;
            const answersToShow = answerGroups.slice(0, displayCount);
            
            let html = '<div class="round-answers-grid">';
            
            answersToShow.forEach((group, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                html += `
                    <div class="answer-group ${rankClass}">
                        <div class="answer-rank">#${index + 1}</div>
                        <div class="answer-content">
                            <div class="answer-text">${group.answer}</div>
                            <div class="answer-stats">
                                <span class="answer-count">${group.count} players</span>
                                <span class="answer-points">${group.points} pts</span>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            if (answerGroups.length > 15) {
                html += `<div class="more-answers-indicator">And ${answerGroups.length - 15} more answers...</div>`;
            }
            
            return html;
        }

        function generateRoundScoresDisplay(players) {
            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
            const displayCount = players.length <= 20 ? players.length : 20;
            const playersToShow = sortedPlayers.slice(0, displayCount);
            
            let html = '<div class="round-scores-list">';
            
            playersToShow.forEach((player, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                html += `
                    <div class="player-score ${rankClass}">
                        <div class="score-rank">#${index + 1}</div>
                        <div class="score-name">${player.name}</div>
                        <div class="score-points">${player.score} pts</div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            if (players.length > 20) {
                html += `<div class="more-scores-indicator">And ${players.length - 20} more players...</div>`;
            }
            
            return html;
        }

        function generateAdvancedRoundDisplay(roundData, columnClass) {
            // Use round-specific scores from roundData instead of cumulative scores
            const players = [...roundData.players].sort((a, b) => b.score - a.score);
            const answerGroups = roundData.answerGroups || [];
            
            console.log('Round data:', roundData);
            console.log('Players:', players);
            console.log('Answer groups:', answerGroups);
            
            // Try to get round-specific player answers, fallback to recent answers
            const playersWithAnswers = players.map(player => {
                let roundAnswers = [];
                
                // Try multiple sources for player answers
                if (roundData.playerAnswers && roundData.playerAnswers[player.id]) {
                    roundAnswers = roundData.playerAnswers[player.id];
                } else if (gameState.answers && gameState.answers[player.id]) {
                    // Fallback to current game state answers
                    roundAnswers = Array.isArray(gameState.answers[player.id]) 
                        ? gameState.answers[player.id] 
                        : [gameState.answers[player.id]];
                } else {
                    // Generate player-specific answers based on answer groups and player data
                    const playerSpecificAnswers = [];
                    
                    // Find answers that this specific player gave
                    answerGroups.forEach(group => {
                        if (group.players && group.players.includes(player.name)) {
                            playerSpecificAnswers.push(group.answer);
                        }
                    });
                    
                    // If we found player-specific answers, use them
                    if (playerSpecificAnswers.length >= 5) {
                        roundAnswers = playerSpecificAnswers.slice(0, 5);
                    } else {
                        // Mix of player-specific answers and varied samples
                        const sampleAnswers = ['dog', 'horse', 'rabbit', 'rooster', 'tiger'];
                        roundAnswers = [...playerSpecificAnswers, ...sampleAnswers].slice(0, 5);
                    }
                }
                
                // Ensure exactly 5 answers for consistent display
                if (roundAnswers.length > 5) {
                    roundAnswers = roundAnswers.slice(0, 5);
                } else {
                    while (roundAnswers.length < 5) {
                        roundAnswers.push('---');
                    }
                }
                
                return {
                    ...player,
                    roundAnswers: roundAnswers,
                    roundScore: player.score || 0  // Use the round-specific score from roundData
                };
            });
            
            console.log('Players with answers:', playersWithAnswers);
            
            if (columnClass === 'leaderboard-single-column') {
                return generateSingleColumnDisplay(playersWithAnswers, answerGroups, roundData);
            } else if (columnClass === 'leaderboard-two-column') {
                return generateTwoColumnDisplay(playersWithAnswers, answerGroups, roundData);
            } else {
                return generateThreeColumnDisplay(playersWithAnswers, answerGroups, roundData);
            }
        }

        function generateSingleColumnDisplay(players, answerGroups, roundData) {
            let html = '<div class="leaderboard-single-column">';
            
            players.forEach((player, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                const medal = index < 3 ? ['ü•á', 'ü•à', 'ü•â'][index] : '';
                
                html += `
                    <div class="leaderboard-row ${rankClass}">
                        <div class="player-info">
                            <span class="player-rank">${medal || `#${index + 1}`}</span>
                            <span class="player-name">${player.name}</span>
                            <span class="player-score">${player.score} pts</span>
                        </div>
                        <div class="player-answers">
                            ${generatePlayerAnswersDisplay(player.roundAnswers || [], answerGroups, roundData)}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }

        function generateTwoColumnDisplay(players, answerGroups, roundData) {
            let html = '<div class="leaderboard-two-column">';
            
            // Create 2 columns
            for (let colIndex = 0; colIndex < 2; colIndex++) {
                html += `<div class="leaderboard-column column-${colIndex + 1}">`;
                
                // Add players to this column (every 2nd player starting from colIndex)
                for (let i = colIndex; i < players.length; i += 2) {
                    const player = players[i];
                    const globalIndex = i;
                    const rankClass = globalIndex < 3 ? `rank-${globalIndex + 1}` : '';
                    const medal = globalIndex < 3 ? ['ü•á', 'ü•à', 'ü•â'][globalIndex] : '';
                    
                    html += `
                        <div class="leaderboard-row ${rankClass}">
                            <div class="player-info">
                                <span class="player-rank">${medal} #${globalIndex + 1}</span>
                                <span class="player-name">${player.name}</span>
                                <span class="player-score">${player.score} pts</span>
                            </div>
                            <div class="player-answers">
                                ${generatePlayerAnswersDisplay(player.roundAnswers || [], answerGroups, roundData)}
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        function generateThreeColumnDisplay(players, answerGroups, roundData) {
            let html = '<div class="leaderboard-three-column">';
            
            // Create 3 columns
            for (let colIndex = 0; colIndex < 3; colIndex++) {
                html += `<div class="leaderboard-column column-${colIndex + 1}">`;
                
                // Add players to this column (every 3rd player starting from colIndex)
                for (let i = colIndex; i < players.length; i += 3) {
                    const player = players[i];
                    const globalIndex = i;
                    const rankClass = globalIndex < 3 ? `rank-${globalIndex + 1}` : '';
                    const medal = globalIndex < 3 ? ['ü•á', 'ü•à', 'ü•â'][globalIndex] : '';
                    
                    html += `
                        <div class="leaderboard-row ${rankClass}">
                            <div class="player-info">
                                <span class="player-rank">${medal} #${globalIndex + 1}</span>
                                <span class="player-name">${player.name}</span>
                                <span class="player-score">${player.score} pts</span>
                            </div>
                            <div class="player-answers">
                                ${generatePlayerAnswersDisplay(player.roundAnswers || [], answerGroups, roundData)}
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        function generatePlayerAnswersDisplay(playerAnswers, answerGroups, roundData) {
            if (!playerAnswers || playerAnswers.length === 0) {
                return '<div class="no-answers-player">No answers submitted</div>';
            }
            
            console.log('generatePlayerAnswersDisplay - Player answers:', playerAnswers);
            console.log('generatePlayerAnswersDisplay - Answer groups:', answerGroups);
            console.log('generatePlayerAnswersDisplay - Round data:', roundData);
            
            let html = '<div class="player-answers-row">';
            
            // For single player games, use the answer groups directly since they represent the actual answers
            if (roundData.players && roundData.players.length === 1) {
                answerGroups.forEach((group, index) => {
                    const points = group.points;
                    const isCorrect = points > 0;
                    const answer = group.answer;
                    
                    console.log(`‚úÖ Using answer group ${index}: "${answer}" - points=${points}, isCorrect=${isCorrect}`);
                    
                    const statusClass = isCorrect ? 'correct-answer' : 'wrong-answer';
                    
                    // Determine text size based on answer length
                    let textSizeClass = 'medium';
                    if (answer.length <= 8) {
                        textSizeClass = 'short';
                    } else if (answer.length <= 15) {
                        textSizeClass = 'medium';
                    } else if (answer.length <= 25) {
                        textSizeClass = 'long';
                    } else {
                        textSizeClass = 'very-long';
                    }
                    
                    html += `
                        <div class="answer-card-small ${statusClass}" data-answer-length="${textSizeClass}">
                            <span class="answer-text-small">${answer}</span>
                            <span class="answer-points-small">${points}</span>
                        </div>
                    `;
                });
            } else {
                // For multi-player games, match player answers with answer groups
                playerAnswers.forEach((answer, index) => {
                    let points = 0;
                    let isCorrect = false;
                    
                    // Find the answer group that matches this player's answer
                    const answerGroup = answerGroups.find(group => {
                        const normalizedGroupAnswer = group.answer.toLowerCase().trim();
                        const normalizedPlayerAnswer = answer.toLowerCase().trim();
                        
                        // Exact match
                        if (normalizedGroupAnswer === normalizedPlayerAnswer) {
                            return true;
                        }
                        
                        // Partial match: player answer contained in group answer
                        if (normalizedGroupAnswer.includes(normalizedPlayerAnswer)) {
                            return true;
                        }
                        
                        // Reverse partial match: group answer contained in player answer
                        if (normalizedPlayerAnswer.includes(normalizedGroupAnswer)) {
                            return true;
                        }
                        
                        return false;
                    });
                    
                    if (answerGroup) {
                        points = answerGroup.points;
                        isCorrect = points > 0;
                        console.log(`‚úÖ Found answer group for "${answer}": points=${points}, isCorrect=${isCorrect}`);
                    } else {
                        console.log(`‚ùå No answer group found for "${answer}"`);
                    }
                    
                    const statusClass = isCorrect ? 'correct-answer' : 'wrong-answer';
                    
                    // Determine text size based on answer length
                    let textSizeClass = 'medium';
                    if (answer.length <= 8) {
                        textSizeClass = 'short';
                    } else if (answer.length <= 15) {
                        textSizeClass = 'medium';
                    } else if (answer.length <= 25) {
                        textSizeClass = 'long';
                    } else {
                        textSizeClass = 'very-long';
                    }
                    
                    html += `
                        <div class="answer-card-small ${statusClass}" data-answer-length="${textSizeClass}">
                            <span class="answer-text-small">${answer}</span>
                            <span class="answer-points-small">${points}</span>
                        </div>
                    `;
                });
            }
            
            html += '</div>';
            return html;
        }

        function generateLeaderboardDisplay(sortedPlayers) {
            const displayCount = sortedPlayers.length <= 20 ? sortedPlayers.length : 20;
            const playersToShow = sortedPlayers.slice(0, displayCount);
            
            let html = '<div class="leaderboard-list">';
            
            playersToShow.forEach((player, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                const medal = index < 3 ? ['ü•á', 'ü•à', 'ü•â'][index] : '';
                html += `
                    <div class="leaderboard-entry ${rankClass}">
                        <div class="leaderboard-rank">
                            ${medal} #${index + 1}
                        </div>
                        <div class="leaderboard-name">${player.name}</div>
                        <div class="leaderboard-score">${player.score} pts</div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            if (sortedPlayers.length > 20) {
                html += `<div class="more-leaderboard-indicator">And ${sortedPlayers.length - 20} more players...</div>`;
            }
            
            return html;
        }

        function showRoundHistory() {
            const roundHistory = gameState.roundHistory;
            
            document.getElementById('displayScreen').innerHTML = `
                <div class="round-history-container">
                    <div class="history-header">
                        <h1>üìö Round History</h1>
                        <p class="history-subtitle">Complete Game Breakdown</p>
                    </div>
                    
                    <div class="history-content">
                        ${roundHistory.map((round, index) => `
                            <div class="history-round">
                                <h3>Round ${round.roundNumber}</h3>
                                <p>Questions ${round.questionStart} - ${round.questionEnd}</p>
                                <div class="round-summary">
                                    <div class="top-answers">
                                        <h4>Top Answers:</h4>
                                        ${round.answerGroups.slice(0, 3).map(group => 
                                            `<span class="answer-tag">${group.answer} (${group.points}pts)</span>`
                                        ).join('')}
                                    </div>
                                    <div class="top-players">
                                        <h4>Top Players:</h4>
                                        ${round.players.slice(0, 3).map(player => 
                                            `<span class="player-tag">${player.name} (${player.score}pts)</span>`
                                        ).join('')}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="history-navigation">
                        <button onclick="showLeaderboardScreen()" class="btn btn-primary">Back to Leaderboard</button>
                    </div>
                </div>
            `;
        }

        function showLeaderboard() {
            updateDisplayFromGameState({...gameState, gameState: 'leaderboard'});
        }

        function continueToNextRound() {
            // This would be triggered by the host, but for now we'll simulate it
            updateDisplayFromGameState({...gameState, gameState: 'playing'});
        }

        // Initialize display (handled by the new event listener below)
        
        // Debug: Log any page visibility changes
        document.addEventListener('visibilitychange', () => {
            console.log('üëÅÔ∏è Page visibility changed:', document.visibilityState, 'at:', new Date().toLocaleTimeString());
        });
        
        // Debug: Log any page focus changes
        window.addEventListener('focus', () => {
            console.log('üéØ Page focused at:', new Date().toLocaleTimeString());
        });
        
        window.addEventListener('blur', () => {
            console.log('üí§ Page blurred at:', new Date().toLocaleTimeString());
        });

        function generateQRCode(elementId, url) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.error(`Element with id '${elementId}' not found`);
                return;
            }
            
            console.log(`Generating QR code for ${url} in element ${elementId}`);
            
            // Create a larger QR code using a reliable online service
            const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(url)}`;
            
            element.innerHTML = `
                <img src="${qrCodeUrl}" 
                     alt="QR Code to join game" 
                     style="width: 300px; height: 300px; background: white; border-radius: 12px;"
                     onerror="this.parentElement.innerHTML='<div style=\\'width: 300px; height: 300px; background: white; border: 2px solid #333; display: flex; align-items: center; justify-content: center; font-size: 16px; text-align: center; padding: 20px;\\'><a href=\\'${url}\\' target=\\'_blank\\' style=\\'color: #333; text-decoration: none;\\'>Click to join<br>${url}</a></div>'">
            `;
        }

        // Dynamic Sheep Carousel System
        async function initializeSheepCarousel() {
            try {
                console.log('üêë Fetching sheep photos...');
                const response = await fetch('/api/sheep-urls');
                console.log('üêë API Response status:', response.status);
                const data = await response.json();
                console.log('üêë API Response data:', data);
                
                if (data.urls && data.urls.length > 0) {
                    // Preload a subset before starting the carousel
                    const decoded = await (async () => {
                        const decodedUrls = new Set();
                        const limit = Math.min(data.urls.length, 20);
                        const firstBatch = data.urls.slice(0, limit);
                        await Promise.all(firstBatch.map(url => new Promise(resolve => {
                            const img = new Image();
                            let done = false;
                            const to = setTimeout(() => { if (!done) { done = true; resolve(); } }, 4000);
                            img.onload = () => { if (!done) { done = true; clearTimeout(to); decodedUrls.add(url); resolve(); } };
                            img.onerror = () => { if (!done) { done = true; clearTimeout(to); resolve(); } };
                            img.src = url;
                            if (img.decode) { img.decode().then(() => { decodedUrls.add(url); }).catch(() => {}); }
                        })));
                        return Array.from(decodedUrls);
                    })();
                    const prioritized = decoded.length > 0 ? [...decoded, ...data.urls.filter(u => !decoded.includes(u))] : data.urls;
                    updateSheepCarousel(prioritized);
                    console.log(`üêë Preloaded ${decoded.length}/${data.urls.length} sheep photos; carousel started`);
                } else {
                    console.log('üêë No uploaded sheep photos found, using default background');
                }
            } catch (error) {
                console.error('Failed to load sheep photos:', error);
            }
        }

        function updateSheepCarousel(sheepUrls) {
            console.log('üêë Updating carousel with', sheepUrls.length, 'sheep photos');
            
            // Remove existing animation if it exists
            const existingStyle = document.getElementById('dynamic-sheep-carousel');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (sheepUrls.length === 0) {
                console.log('üêë No sheep URLs provided');
                return;
            }

            // Calculate timing for smooth transitions with 10 seconds static time per image
            const staticTimePerImage = 10; // 10 seconds static time per image
            const transitionTime = 2; // 2 seconds for transition
            const totalTimePerImage = staticTimePerImage + transitionTime;
            const totalDuration = Math.max(60, sheepUrls.length * totalTimePerImage);
            const stepPercentage = 100 / sheepUrls.length;

            // Generate CSS keyframes with static periods
            let keyframes = '@keyframes sheepCarousel {\n';
            sheepUrls.forEach((url, index) => {
                const startPercentage = (index * stepPercentage).toFixed(2);
                const endPercentage = ((index + 1) * stepPercentage).toFixed(2);
                
                // Add static period for this image (most of the time)
                const staticStart = parseFloat(startPercentage);
                const staticEnd = parseFloat(endPercentage) - (transitionTime / totalTimePerImage * stepPercentage);
                
                keyframes += `    ${staticStart}% { background-image: url('${url}'); }\n`;
                keyframes += `    ${staticEnd.toFixed(2)}% { background-image: url('${url}'); }\n`;
            });
            // Loop back to first image
            keyframes += `    100% { background-image: url('${sheepUrls[0]}'); }\n`;
            keyframes += '}\n\n';

            // Set initial background and animation
            keyframes += `.playing-container::after {\n`;
            keyframes += `    background-image: url('${sheepUrls[0]}');\n`;
            keyframes += `    animation: sheepCarousel ${totalDuration}s linear infinite;\n`;
            keyframes += `}\n`;

            console.log('üêë Generated CSS for carousel:', keyframes.slice(0, 200) + '...');
            console.log('üêë Total duration:', totalDuration + 's, Static time per image:', staticTimePerImage + 's');

            // Inject the CSS
            const style = document.createElement('style');
            style.id = 'dynamic-sheep-carousel';
            style.textContent = keyframes;
            document.head.appendChild(style);
            
            console.log('üêë Carousel CSS injected, total duration:', totalDuration + 's');
        }

        // Initialize socket connection on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Register service worker for caching stability
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js').catch(err => console.warn('SW registration failed', err));
            }
            initializeSocket();
            initializeSheepCarousel();
        });

        // Refresh carousel every 5 minutes to pick up new uploads
        setInterval(initializeSheepCarousel, 5 * 60 * 1000);
        

        // Helper functions for the new question results layout
        function categorizeAnswersForDisplay() {
            // Use current question-specific data to avoid persistence issues
            const currentQuestionIndex = gameState.currentQuestion;
            const submittedAnswers = gameState.currentAnswerGroups || [];
            const correctAnswers = gameState.currentQuestionData?.correct_answers || [];
            const wrongAnswers = [];
            const correctNotGiven = [];
            
            console.log('Categorizing answers for question:', currentQuestionIndex);
            console.log('Current answer groups:', submittedAnswers);
            console.log('Correct answers for this question:', correctAnswers);
            
            // Create a set of submitted answer texts (normalized)
            const submittedTexts = new Set();
            submittedAnswers.forEach(group => {
                submittedTexts.add(group.answer.toLowerCase().trim());
            });
            
            // Separate correct answers that weren't submitted
            correctAnswers.forEach(correctAnswer => {
                const normalized = correctAnswer.toLowerCase().trim();
                if (!submittedTexts.has(normalized)) {
                    correctNotGiven.push(correctAnswer);
                }
            });
            
            // Separate wrong answers (those with 0 points) - only for current question
            submittedAnswers.forEach(group => {
                if (group.points === 0) {
                    wrongAnswers.push(group);
                }
            });
            
            // Filter submitted answers to only correct ones (points > 0)
            const correctSubmitted = submittedAnswers.filter(group => group.points > 0);
            
            console.log('Categorized - Correct submitted:', correctSubmitted.length, 'Wrong:', wrongAnswers.length, 'Correct not given:', correctNotGiven.length);
            
            return {
                submittedAnswers: correctSubmitted,
                correctNotGiven: correctNotGiven,
                wrongAnswers: wrongAnswers
            };
        }

        function generateTopAnswersDisplay(submittedAnswers) {
            if (!submittedAnswers || submittedAnswers.length === 0) {
                return '<p class="no-answers">No correct answers submitted</p>';
            }
            
            const html = `
                <div class="answers-grid">
                    ${submittedAnswers.map((group, index) => `
                        <div class="answer-card rank-${Math.min(index + 1, 3)}">
                            <div class="answer-rank">#${index + 1}</div>
                            <div class="answer-text">${group.answer}</div>
                            <div class="answer-stats">
                                <div class="answer-count">${group.count} player${group.count !== 1 ? 's' : ''}</div>
                                <div class="answer-points">${group.points} pts</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            return html;
        }

        function generateCorrectNotGivenDisplay(correctNotGiven) {
            if (!correctNotGiven || correctNotGiven.length === 0) {
                return '<p class="no-answers">All correct answers were given!</p>';
            }
            
            const html = `
                <div class="correct-answers-grid">
                    ${correctNotGiven.map(answer => {
                        // Determine text size based on answer length
                        let textSizeClass = 'medium';
                        if (answer.length <= 8) {
                            textSizeClass = 'short';
                        } else if (answer.length <= 15) {
                            textSizeClass = 'medium';
                        } else if (answer.length <= 25) {
                            textSizeClass = 'long';
                        } else {
                            textSizeClass = 'very-long';
                        }
                        
                        return `
                            <div class="correct-answer-badge" data-answer-length="${textSizeClass}">
                                <div class="correct-answer-text">${answer}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            
            return html;
        }

        function generateWrongAnswersDisplay(wrongAnswers) {
            if (!wrongAnswers || wrongAnswers.length === 0) {
                return '<p class="no-answers">No wrong answers submitted.</p>';
            }
            
            return `
                <div class="wrong-answers-grid">
                    ${wrongAnswers.map(group => `
                        <div class="wrong-answer-card">
                            <div class="wrong-answer-text">${group.answer}</div>
                            <div class="wrong-answer-count">${group.count} player${group.count !== 1 ? 's' : ''}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Dynamic scaling calculation based on screen resolution
        function calculateDynamicScaling() {
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            
            console.log(`Screen resolution: ${screenWidth}x${screenHeight}`);
            
            let scaleFactor = 0.65; // Default for 1920x1080
            
            // Calculate scaling based on screen resolution
            if (screenWidth >= 2560) {
                // High-res displays like 2560x1600, 2560x1440, 3840x2160
                scaleFactor = 0.85;
                console.log('High-res display detected, using scale factor: 0.85');
            } else if (screenWidth >= 1921) {
                // Medium displays like 1920x1200, 2048x1536
                scaleFactor = 0.75;
                console.log('Medium-res display detected, using scale factor: 0.75');
            } else {
                // Standard displays like 1920x1080, 1366x768
                scaleFactor = 0.65;
                console.log('Standard display detected, using scale factor: 0.65');
            }
            
            // Apply the scaling factor to CSS variables
            document.documentElement.style.setProperty('--scale-factor', scaleFactor);
            document.documentElement.style.setProperty('--font-scale', scaleFactor);
            
            console.log(`Applied scale factor: ${scaleFactor}`);
            
            // Force a recalculation by triggering a reflow
            document.body.offsetHeight;
            
            // Log the computed value to verify it's working
            const computedScale = getComputedStyle(document.documentElement).getPropertyValue('--scale-factor');
            console.log(`Computed scale factor: ${computedScale}`);
            
            // Calculate what the minmax value should be
            const minmaxValue = 380 * scaleFactor;
            console.log(`Minmax value should be: ${minmaxValue}px`);
            
            // Also set the grid template columns directly via JavaScript as backup
            const topAnswersGrids = document.querySelectorAll('.top-answers-grid, .incorrect-answers-grid');
            console.log(`Found ${topAnswersGrids.length} grid elements to update`);
            topAnswersGrids.forEach((grid, index) => {
                grid.style.gridTemplateColumns = `repeat(auto-fit, minmax(${minmaxValue}px, 1fr))`;
                console.log(`Grid ${index + 1} (${grid.className}): ${grid.style.gridTemplateColumns}`);
                
                // Also log the computed style to see what's actually applied
                const computedStyle = getComputedStyle(grid).gridTemplateColumns;
                console.log(`Grid ${index + 1} computed style: ${computedStyle}`);
                
                // Count how many cards are actually in the grid
                const cards = grid.querySelectorAll('.answer-card, .wrong-answer-card');
                console.log(`Grid ${index + 1} has ${cards.length} cards`);
            });
        }
        
        // Calculate scaling on page load
        document.addEventListener('DOMContentLoaded', calculateDynamicScaling);
        
        // Recalculate on window resize (in case of resolution changes)
        window.addEventListener('resize', calculateDynamicScaling);
        
        // Also calculate immediately if DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', calculateDynamicScaling);
        } else {
            calculateDynamicScaling();
        }

        function generateRoundHistoryDisplay(roundHistory) {
            if (!roundHistory || roundHistory.length === 0) {
                return '<p>No rounds completed yet.</p>';
            }
            
            let html = '<div class="round-history-list">';
            
            roundHistory.forEach((round, index) => {
                const roundNumber = round.roundNumber;
                const questionRange = `Questions ${round.questionStart} - ${round.questionEnd}`;
                const sortedPlayers = [...round.players].sort((a, b) => b.score - a.score);
                
                html += `
                    <div class="round-history-item">
                        <div class="round-header">
                            <h4>Round ${roundNumber}</h4>
                            <span class="round-range">${questionRange}</span>
                        </div>
                        <div class="round-scores">
                            ${sortedPlayers.map((player, playerIndex) => `
                                <div class="round-player-score ${playerIndex < 3 ? `rank-${playerIndex + 1}` : ''}">
                                    <span class="player-name">${player.name}</span>
                                    <span class="player-score">${player.score} pts</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }
    </script>
</body>
</html> 
</html> 