<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEGASheep - Game</title>
    <link rel="stylesheet" href="styles.css?v=2025-08-15T14-33-53">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* Player interface enhancements */
        .connection-pill { display: inline-flex; align-items: center; gap: 6px; padding: 2px 8px; border-radius: 999px; font-size: 12px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .dot.ok { background: #2ecc71; box-shadow: 0 0 6px rgba(46, 204, 113, 0.6); }
        .dot.warn { background: #f1c40f; box-shadow: 0 0 6px rgba(241, 196, 15, 0.6); }
        .dot.err { background: #e74c3c; box-shadow: 0 0 6px rgba(231, 76, 60, 0.6); }
        .connection-toast { position: fixed; top: 12px; right: 12px; background: rgba(0,0,0,0.8); color: #fff; border: 1px solid rgba(255,255,255,0.15); padding: 10px 12px; border-radius: 8px; z-index: 9999; display: none; }
        .answer-progress { height: 8px; background: rgba(0,0,0,0.08); border-radius: 999px; overflow: hidden; margin-top: 8px; }
        .answer-progress-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #28a745, #20c997); transition: width 0.3s ease; }
        .btn-inline { background: transparent; border: 1px solid rgba(255,255,255,0.25); padding: 4px 8px; border-radius: 6px; color: inherit; cursor: pointer; font-size: 12px; }
        .btn-inline:hover { background: rgba(255,255,255,0.08); }
    </style>
</head>
<body>
    <div class="container">
        <!-- Game Status Bar -->
        <div class="game-status">
            <div class="status-item">
                <span class="label">Game:</span>
                <span id="gameCodeDisplay">-</span>
            </div>
            <div class="status-item">
                <span class="label">Player:</span>
                <span id="playerNameDisplay">-</span>
            </div>
            <div class="status-item">
                <span class="label">Round:</span>
                <span id="roundDisplay">-</span>
            </div>
            <div class="status-item">
                <span class="label">Question:</span>
                <span id="questionDisplay">-</span>
            </div>
            <div class="status-item">
                <span class="label">Score:</span>
                <span id="scoreDisplay">0</span>
            </div>
            <div class="status-item">
                <span class="label">Connection:</span>
                <span class="connection-pill"><span id="connectionDot" class="dot warn"></span><span id="connectionText">Connecting‚Ä¶</span></span>
            </div>
        </div>

        <!-- Waiting Screen -->
        <div class="screen active" id="waitingScreen">
            <div class="screen-content">
                <div class="waiting-content">
                    <h1 class="title">üéÆ MEGASheep</h1>
                    <h2>Waiting for game to start...</h2>
                    <div class="loading-spinner"></div>
                    <p id="waitingMessage">Connected to game. The host will start shortly.</p>
                    <div class="player-list">
                        <h3>Players in Game:</h3>
                        <div id="playersList"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Question Screen -->
        <div class="screen" id="questionScreen">
            <div class="screen-content">
                <div class="timer-container">
                    <div class="timer" id="timer">30</div>
                    <div class="timer-label">seconds left</div>
                </div>
                
                <div class="question-container">
                    <h2 id="questionText">Question will appear here</h2>
                    <div class="question-info">
                        <span>Question <span id="currentQuestionNum">1</span> of <span id="totalQuestions">5</span></span>
                    </div>
                </div>
                
                <form id="answerForm" class="answer-form">
                    <div class="form-group">
                        <label for="answerInput">Your Answer:</label>
                        <input type="text" id="answerInput" placeholder="Type your answer here..." maxlength="100" required>
                    </div>
                     <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
                        <button type="submit" class="btn btn-primary" id="submitBtn">Submit Answer</button>
                    </div>
                </form>
                <!-- Multi-purpose communication: answerStatus doubles as input/display -->
                <div id="playerCommRow" style="margin-top:8px; gap:8px; align-items:center; display:flex;">
                    <div id="answerStatus" class="answer-status" role="textbox" aria-multiline="true" contenteditable="true" data-placeholder="Type a private message to host..." style="flex:1; min-height:38px; padding:10px 12px;"></div>
                    <button id="askHostBtn" class="btn btn-secondary" type="button" style="white-space:nowrap;">Send to host</button>
                </div>
                <div id="dmHistory" style="margin-top:6px; font-size:13px; color: #cfd8dc;"></div>
                
                <!-- My Answer Display -->
                <div id="myAnswerDisplay" class="my-answer-display" style="display: none;">
                    <h3>My Answer:</h3>
                    <div class="my-answer-text" id="myAnswerText"></div>
                    <div class="my-answer-status" id="myAnswerStatus">Submitted ‚úì</div>
                </div>
                
                <!-- Removed dedicated status element; handled by contenteditable above -->
                <div id="answerRetryContainer" style="display:none; margin-top:6px;">
                    <button type="button" id="retrySubmitBtn" class="btn-inline">Retry submission</button>
                </div>
                <div class="players-answered">
                    <span id="answeredCount">0</span> of <span id="totalPlayersCount">0</span> players answered
                    <div class="answer-progress"><div id="answerProgressBar" class="answer-progress-bar"></div></div>
                </div>
            </div>
        </div>

        <!-- Results Screen -->
        <div class="screen" id="resultsScreen">
            <div class="screen-content">
                <div class="results-content">
                    <h2>Question Results</h2>
                    <div id="answerGroups"></div>
                    <div class="score-update">
                        <h3>Your Score: <span id="currentScore">0</span></h3>
                    </div>
                    <div class="waiting-next">
                        <p>Waiting for host to continue...</p>
                        <div class="loading-spinner"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Final Results Screen -->
        <div class="screen" id="finalScreen">
            <div class="screen-content">
                <div class="final-content">
                    <h1>üéâ Game Complete!</h1>
                    <div class="final-score">
                        <h2>Your Final Score: <span id="finalScore">0</span></h2>
                    </div>
                    <div class="leaderboard">
                        <h3>Final Leaderboard:</h3>
                        <div id="finalLeaderboard"></div>
                    </div>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="location.href='/'">Play Again</button>
                        <button class="btn btn-secondary" onclick="location.href='/host'">Host New Game</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Error Screen -->
        <div class="screen" id="errorScreen">
            <div class="screen-content">
                <div class="error-content">
                    <h1>‚ö†Ô∏è Connection Error</h1>
                    <p id="errorMessage">Unable to connect to game session.</p>
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="location.href='/'">Join Different Game</button>
                        <button class="btn btn-secondary" onclick="window.location.reload()">Try Again</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('üéØ GAME.HTML EMBEDDED JAVASCRIPT LOADED!');
        console.log('üéØ This should appear if game.html JavaScript is being used');
        
        let socket;
        let gameCode;
        let playerName;
        let gameState = null;
        let reconnectionTimeoutId = null;
        let awaitingAnswerAck = false;
        let answerAckTimerId = null;
        
        // Check session data on load - CRITICAL FIX: Check URL params first for mobile refresh persistence
        window.addEventListener('load', function() {
            // Priority: URL params > sessionStorage for mobile refresh handling
            const urlParams = new URLSearchParams(window.location.search);
            const urlGameCode = urlParams.get('game') || urlParams.get('code') || urlParams.get('gameCode') || urlParams.get('room');
            const urlPlayerName = urlParams.get('name') || urlParams.get('player') || urlParams.get('playerName');
            
            gameCode = urlGameCode || sessionStorage.getItem('gameCode') || localStorage.getItem('player.gameCode');
            playerName = urlPlayerName || sessionStorage.getItem('playerName') || localStorage.getItem('player.name');
            
            if (!gameCode || !playerName) {
                showError('No game session found. Please join a game first.');
                setTimeout(() => {
                    window.location.href = '/';
                }, 2000);
                return;
            }
            
            // Save to both session and local storage for persistence
            try {
                sessionStorage.setItem('gameCode', gameCode);
                sessionStorage.setItem('playerName', playerName);
                localStorage.setItem('player.gameCode', gameCode);
                localStorage.setItem('player.name', playerName);
            } catch (_) {}
            
            // Update display
            document.getElementById('gameCodeDisplay').textContent = gameCode;
            document.getElementById('playerNameDisplay').textContent = playerName;
            
            // Initialize socket connection
            initializeSocket();
        });
        
        function initializeSocket() {
            console.log('Player: Initializing socket connection...');
            console.log('Player: Socket.IO version check - io object:', typeof io);
            console.log('Player: Socket.IO version check - io function:', io);
            
            socket = io({
                transports: ['websocket', 'polling'],
                timeout: 20000,
                forceNew: false,
                reconnection: true,
                reconnectionAttempts: 25,
                reconnectionDelay: 500,
                reconnectionDelayMax: 3000,
                maxReconnectionAttempts: 25,
                autoConnect: true
            });
            console.log('Player: Socket object created:', socket);
            console.log('Player: Socket connected state:', socket.connected);
            console.log('Player: Socket ID before connection:', socket.id);
            
            // Register ALL event handlers BEFORE connecting
            console.log('Player: Registering event handlers...');
            
            socket.on('disconnect', () => {
                console.log('Player: Disconnected from server');
                updateConnectionUI('disconnected');
                showConnectionToast('Lost connection. Reconnecting‚Ä¶');
                clearTimeout(reconnectionTimeoutId);
                reconnectionTimeoutId = setTimeout(() => {
                    showError('Unable to reconnect to game server.');
                }, 15000);
            });
            
            socket.on('connect_error', (error) => {
                console.error('Player: Connection error:', error);
                updateConnectionUI('connecting');
                showConnectionToast('Connection issue. Retrying‚Ä¶');
            });
            
            socket.on('error', (error) => {
                console.error('Player: Socket error:', error);
            });

            // Reconnection lifecycle feedback
            if (socket.io) {
                socket.io.on('reconnect_attempt', (attempt) => {
                    updateConnectionUI('connecting');
                    showConnectionToast(`Reconnecting (attempt ${attempt})‚Ä¶`);
                });
                socket.io.on('reconnect', () => {
                    clearTimeout(reconnectionTimeoutId);
                    updateConnectionUI('connected');
                    showConnectionToast('Reconnected!', 2500);
                });
                socket.io.on('reconnect_error', () => {
                    updateConnectionUI('connecting');
                    showConnectionToast('Reconnection failed. Trying again‚Ä¶');
                });
                socket.io.on('reconnect_failed', () => {
                    updateConnectionUI('disconnected');
                    showConnectionToast('Could not reconnect.');
                });
            }
            
            // Game events
            socket.on('gameJoined', (data) => {
                console.log('Player: Joined game successfully', data);
                console.log('Player: Received game state with', data.gameState?.players?.length || 0, 'players');
                console.log('Player: Socket ID:', socket.id, 'Game Code:', gameCode);
                updateGameState(data.gameState);
                updatePlayersList(data.gameState.players);
                
                // Ensure we show ourselves in the player list
                if (data.gameState && data.gameState.players) {
                    const currentPlayer = data.gameState.players.find(p => p.name === playerName);
                    if (!currentPlayer) {
                        console.log('Player: Adding self to player list');
                        data.gameState.players.push({
                            id: socket.id,
                            name: playerName,
                            score: 0,
                            isVirtual: false
                        });
                        updatePlayersList(data.gameState.players);
                    } else {
                        console.log('Player: Self already in player list');
                    }
                }
                
                // Test room membership by emitting a test event
                console.log('Player: Testing room membership...');
                socket.emit('testRoomMembership', { gameCode: gameCode });
            });
            
            socket.on('gameStarted', (data) => {
                console.log('Game started');
                updateGameState(data);
                showScreen('questionScreen');
                startQuestion(data);
            });
            
            socket.on('nextQuestion', (data) => {
                console.log('Next question');
                updateGameState(data);
                startQuestion(data);
                showScreen('questionScreen');
                // Clear any lingering edit prompts for the new question
                try {
                        const existing = document.getElementById('editRequestNotice');
                        if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
                    const statusEl = document.getElementById('answerStatus');
                    statusEl.innerHTML = '';
                    statusEl.className = 'answer-status';
                    const input = document.getElementById('answerInput');
                    const btn = document.getElementById('submitBtn');
                    input.disabled = false; btn.disabled = false; input.value = '';
                } catch (_) {}
            });
            
            socket.on('questionComplete', (data) => {
                console.log('üìù Question complete event received:', data);
                console.log('üìù data.gameState =', data.gameState);
                console.log('üìù data.gameState === "grading" =', data.gameState === 'grading');
                updateGameState(data);
                // If this player has a pending clarification, surface that immediately
                try {
                    const me = (data && Array.isArray(data.pendingEdits)) ? data.pendingEdits.find(p => p.playerName === playerName) : null;
                    if (me) {
                        console.log('‚úèÔ∏è Pending edit persists into grading for this player');
                        const statusEl = document.getElementById('answerStatus');
                        statusEl.innerHTML = `‚úèÔ∏è Edit requested by host: ${me.reason || 'Please be more specific'}`;
                        statusEl.className = 'answer-status warning';
                        const input = document.getElementById('answerInput');
                        const btn = document.getElementById('submitBtn');
                        input.disabled = false; btn.disabled = false;
                        if (me.originalAnswer && !input.value) input.value = me.originalAnswer;
                        showScreen('questionScreen');
                        input.focus();
                        return;
                    }
                } catch (_) {}
                if (data.gameState === 'grading') {
                    console.log('üéØ Calling showGradingWait with data:', data);
                    showGradingWait(data);
                } else {
                    console.log('üìä Calling showResults with data:', data);
                    showResults(data);
                }
                showScreen('resultsScreen');
            });
            
            socket.on('gradingComplete', (data) => {
                console.log('Grading complete');
                updateGameState(data);
                showResults(data);
                showScreen('resultsScreen');
            });

            // Private host answer for this player
            socket.on('hostAnswer', (data) => {
                console.log('üí¨ [player] hostAnswer received (game.html):', data);
                try {
                    const msg = data && data.answer ? data.answer : '';
                    if (!msg) return;
                    
                    // Show toast notification for host response
                    showToast(`üí¨ Host responded: ${msg}`, 'info');
                    
                    const statusEl = document.getElementById('answerStatus');
                    if (statusEl && statusEl.getAttribute('contenteditable') === 'true') {
                        statusEl.innerText = `üí¨ Host: ${msg}`;
                    } else if (statusEl) {
                        statusEl.innerHTML = `üí¨ Host: ${msg}`;
                        statusEl.className = 'answer-status info';
                    }
                } catch (_) {}
            });
            
            socket.on('gameFinished', (data) => {
                console.log('Game finished');
                updateGameState(data);
                showFinalResults(data);
                showScreen('finalScreen');
            });
            
            socket.on('gameEnded', (data) => {
                showError('Game has been ended by the host.');
                setTimeout(() => {
                    window.location.href = '/';
                }, 3000);
            });
            
            socket.on('playerJoined', (newGameState) => {
                console.log('Player: Another player joined', newGameState);
                if (newGameState) {
                    gameState = newGameState;
                    updatePlayersList(gameState.players);
                }
            });
            
            socket.on('playerLeft', (newGameState) => {
                if (newGameState) {
                    gameState = newGameState;
                    updatePlayersList(gameState.players);
                }
            });
            
            socket.on('virtualPlayerJoined', (data) => {
                console.log('Player: Virtual player joined event received:', data);
                
                // Initialize gameState if it doesn't exist
                if (!gameState) {
                    console.log('Player: Initializing gameState for virtual player');
                    gameState = { players: [] };
                }
                
                if (gameState.players) {
                    const existingPlayer = gameState.players.find(p => p.id === data.playerId);
                    if (!existingPlayer) {
                        gameState.players.push({
                            id: data.playerId,
                            name: data.playerName,
                            score: 0,
                            isVirtual: true
                        });
                        console.log(`üé≠ Added virtual player ${data.playerName} to player interface`);
                        updatePlayersList(gameState.players);
                    } else {
                        console.log(`üé≠ Virtual player ${data.playerName} already exists in player interface`);
                    }
                }
                
                // Update full game state if provided
                if (data.gameState) {
                    console.log('Player: Updating full game state from virtual player event');
                    gameState = data.gameState;
                    updatePlayersList(gameState.players);
                }
            });
            
            socket.on('timerUpdate', (data) => {
                updateTimer(data.timeLeft);
            });
            
            socket.on('answerUpdate', (data) => {
                updateAnswerCount(data.answersReceived, data.totalPlayers);
            });
            
            socket.on('answerSubmitted', () => {
                document.getElementById('answerStatus').innerHTML = '‚úÖ Answer submitted successfully!';
                document.getElementById('answerStatus').className = 'answer-status success';
                document.getElementById('submitBtn').disabled = true;
                document.getElementById('answerInput').disabled = true;
                awaitingAnswerAck = false;
                clearTimeout(answerAckTimerId);
                document.getElementById('answerRetryContainer').style.display = 'none';
            });

            // Host requested a more specific answer
            socket.on('requireAnswerEdit', (data) => {
                try {
                    const reason = (data && data.reason) ? data.reason : 'Please refine your answer';
                    console.log('‚úèÔ∏è requireAnswerEdit received:', data);
                    
                    // Show toast notification instead of inline message
                    showToast(`‚úèÔ∏è Edit requested by host: ${reason}`, 'warning');
                    
                    const input = document.getElementById('answerInput');
                    const btn = document.getElementById('submitBtn');
                    input.disabled = false;
                    btn.disabled = false;
                    // Prefill with original answer if provided
                    if (data && data.originalAnswer && !input.value) {
                        input.value = data.originalAnswer;
                    }
                    // Ensure the question screen is visible (works even during grading)
                    if (!document.getElementById('questionScreen').classList.contains('active')) {
                        console.log('‚úèÔ∏è Switching to questionScreen for clarification');
                        showScreen('questionScreen');
                    }
                    input.focus();
                } catch (e) {
                    console.warn('Failed to present edit request', e);
                }
            });
            
            socket.on('gameError', (data) => {
                console.log('Player: Game error received:', data);
                showError(data.message);
            });
            
            socket.on('testEvent', (data) => {
                console.log('Player: Received test event from server:', data);
            });
            
            socket.on('pong', (data) => {
                console.log('Player: Received pong from server:', data);
            });
            
            console.log('Player: All event handlers registered');
            
            // Now handle the connection event
            socket.on('connect', () => {
                console.log('Player: Connected to server with socket ID:', socket.id);
                console.log('Player: Socket connected state after connect:', socket.connected);
                console.log('Player: Joining game with code:', gameCode, 'and name:', playerName);
                updateConnectionUI('connected');
                hideConnectionToast();
                
                // Test the connection with a ping
                console.log('Player: Sending ping to server...');
                socket.emit('ping', { message: 'Player interface ping' });
                
                console.log('Player: Sending joinGame event...');
                socket.emit('joinGame', { gameCode, playerName });
            });
            
            console.log('Player: Socket initialization complete');
        }
        
        function updateGameState(state) {
            gameState = state;
            
            // Update displays
            document.getElementById('roundDisplay').textContent = state.currentRound || 1;
            document.getElementById('questionDisplay').textContent = `${(state.currentQuestion || 0) + 1}`;
            
            // Update player score
            const currentPlayer = state.players.find(p => p.name === playerName);
            if (currentPlayer) {
                document.getElementById('scoreDisplay').textContent = currentPlayer.score || 0;
                document.getElementById('currentScore').textContent = currentPlayer.score || 0;
                document.getElementById('finalScore').textContent = currentPlayer.score || 0;
            }
        }
        
        // Utility function to trim long names with ellipsis
        function trimPlayerName(name, maxLength = 15) {
            if (!name) return '';
            return name.length > maxLength ? name.substring(0, maxLength) + '...' : name;
        }

        function updatePlayersList(players) {
            console.log('Player: Updating players list with', players.length, 'players:', players);
            const playersListDiv = document.getElementById('playersList');
            playersListDiv.innerHTML = '';
            
            players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item';
                const trimmedName = trimPlayerName(player.name);
                playerDiv.innerHTML = `
                    <span class="player-name">${trimmedName}</span>
                    <span class="player-score">${player.score || 0}</span>
                `;
                playersListDiv.appendChild(playerDiv);
            });
            
            document.getElementById('totalPlayersCount').textContent = players.length;
            console.log('Player: Updated player list, total count:', players.length);
        }
        
        function startQuestion(gameState) {
            if (!gameState.questions || gameState.currentQuestion >= gameState.questions.length) {
                showError('No question available');
                return;
            }
            
            const question = gameState.questions[gameState.currentQuestion];
            document.getElementById('questionText').textContent = question.prompt;
            
            // Calculate round and question within round
            const questionNumber = gameState.currentQuestion + 1;
            const roundNumber = Math.ceil(questionNumber / gameState.questionsPerRound);
            const questionInRound = ((questionNumber - 1) % gameState.questionsPerRound) + 1;
            
            document.getElementById('currentQuestionNum').textContent = questionInRound;
            document.getElementById('totalQuestions').textContent = gameState.questionsPerRound;
            
            // Reset form
            document.getElementById('answerInput').value = '';
            document.getElementById('answerInput').disabled = false;
            document.getElementById('submitBtn').disabled = false;
            document.getElementById('answerStatus').innerHTML = '';
            document.getElementById('answerStatus').className = 'answer-status';
            
            // Hide "My answer" display
            document.getElementById('myAnswerDisplay').style.display = 'none';
            
            // Focus on input
            document.getElementById('answerInput').focus();
            
            // Reset answer count
            updateAnswerCount(0, gameState.players.length);
        }
        
        function updateTimer(timeLeft) {
            const timerElement = document.getElementById('timer');
            timerElement.textContent = timeLeft;
            
            // Add visual urgency
            if (timeLeft <= 10) {
                timerElement.classList.add('urgent');
                if (timeLeft === 10 && navigator.vibrate) {
                    navigator.vibrate(150);
                }
            } else {
                timerElement.classList.remove('urgent');
            }
        }
        
        function updateAnswerCount(answered, total) {
            document.getElementById('answeredCount').textContent = answered;
            document.getElementById('totalPlayersCount').textContent = total;
            const pct = total > 0 ? Math.max(0, Math.min(100, Math.round((answered / total) * 100))) : 0;
            const bar = document.getElementById('answerProgressBar');
            if (bar) bar.style.width = pct + '%';
        }
        
        function showGradingWait(gameState) {
            console.log('üéØ showGradingWait called - updating player interface');
            const resultsContent = document.querySelector('#resultsScreen .results-content');
            const submittedAnswer = window.lastSubmittedAnswer || 'No answer submitted';
            const me = (gameState && gameState.players || []).find(p => p.name === playerName) || {};
            const currentScore = me.score || 0;
            resultsContent.innerHTML = `
                <div class="hero-card" style="background: rgba(0,123,255,0.10); border:1px solid rgba(0,123,255,0.30); border-radius:12px; padding:16px; margin-bottom:14px;">
                    <div style="font-weight:600; color:#cfe8ff; font-size:13px; letter-spacing:.3px;">Your Answer</div>
                    <div style="font-size:20px; color:#fff; margin:6px 0 10px 0; word-break:break-word;">${submittedAnswer}</div>
                    <div style="display:flex; align-items:center; gap:10px;">
                        <div class="loading-spinner"></div>
                        <div style="color:#90caf9;">Waiting for grading‚Ä¶</div>
                        <div style="margin-left:auto; font-weight:700; color:#fff;">Score: ${currentScore}</div>
                    </div>
                </div>
                <details style="background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:10px; padding:10px 12px;">
                    <summary style="cursor:pointer; color:#cfd8dc;">How scoring works</summary>
                    <div style="margin-top:8px; color:#b0bec5; font-size:14px;">Points = Total responses √∑ Responses with the same answer (rounded up). Rarer answers earn more points.</div>
                </details>
            `;
            console.log('‚úÖ showGradingWait completed - new interface should be visible');
        }

        function showResults(gameState) {
            const container = document.querySelector('#resultsScreen .results-content');
            const groups = Array.isArray(gameState.currentAnswerGroups) ? gameState.currentAnswerGroups : [];
            const me = (gameState.players || []).find(p => p.name === playerName) || { score: 0 };
            let myGroup = groups.find(g => Array.isArray(g.players) && g.players.includes(playerName));
            const myAnswer = myGroup ? myGroup.answer : (window.lastSubmittedAnswer || '‚Äî');
            const myPoints = myGroup ? (myGroup.points || 0) : 0;
            const myCount = myGroup ? (myGroup.count || (myGroup.players?.length || 1)) : 1;
            container.innerHTML = '';

            // Hero card with your result
            const hero = document.createElement('div');
            hero.className = 'hero-card';
            hero.style.cssText = 'background: rgba(46,204,113,0.10); border:1px solid rgba(46,204,113,0.30); border-radius:12px; padding:16px; margin-bottom:14px;';
            hero.innerHTML = `
                <div style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
                    <div style="font-weight:600; color:#c8e6c9; font-size:13px; letter-spacing:.3px;">Your Answer</div>
                    <div style="margin-left:auto; font-weight:700; color:#fff;">Score: ${me.score || 0}</div>
                </div>
                <div style="font-size:20px; color:#fff; margin:6px 0 2px 0; word-break:break-word;">${myAnswer}</div>
                <div style="display:flex; gap:10px; align-items:center; color:#a5d6a7;">
                    <div style="font-size:18px; font-weight:800; color:#fff;">+${myPoints}</div>
                    <div>this question</div>
                    <div style="margin-left:auto; color:#cfd8dc;">${myCount > 1 ? (myCount + ' players matched') : 'Unique answer!'}</div>
                </div>
            `;
            container.appendChild(hero);

            // Collapsible: How others answered
            const details = document.createElement('details');
            details.style.cssText = 'background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.12); border-radius:10px; padding:10px 12px;';
            details.open = false;
            const summary = document.createElement('summary');
            summary.textContent = 'How others answered';
            summary.style.cursor = 'pointer';
            details.appendChild(summary);

            const list = document.createElement('div');
            list.style.marginTop = '8px';
            if (groups.length === 0) {
                list.innerHTML = '<div style="color:#b0bec5;">No answers were submitted for this question.</div>';
            } else {
                groups.forEach(g => {
                    const row = document.createElement('div');
                    row.className = 'answer-group';
                    row.innerHTML = `
                        <div class="answer-text">"${g.answer}"</div>
                        <div class="answer-stats">
                            <span class="answer-count">${g.count} ${g.count === 1 ? 'person' : 'people'}</span>
                            <span class="answer-points">+${g.points} points each</span>
                        </div>
                        <div class="answer-players">${(g.players || []).join(', ')}</div>
                    `;
                    list.appendChild(row);
                });
            }
            details.appendChild(list);
            container.appendChild(details);
        }
        
        function showFinalResults(gameState) {
            const leaderboardDiv = document.getElementById('finalLeaderboard');
            leaderboardDiv.innerHTML = '';
            
            // Sort players by score
            const sortedPlayers = [...gameState.players].sort((a, b) => (b.score || 0) - (a.score || 0));
            
            sortedPlayers.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `leaderboard-item ${index === 0 ? 'winner' : ''}`;
                playerDiv.innerHTML = `
                    <span class="rank">${index + 1}</span>
                    <span class="name">${player.name}</span>
                    <span class="score">${player.score || 0}</span>
                `;
                leaderboardDiv.appendChild(playerDiv);
            });
        }
        
        function showScreen(screenId) {
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Show target screen
            document.getElementById(screenId).classList.add('active');
        }
        
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            showScreen('errorScreen');
        }

        function updateConnectionUI(state) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            if (!dot || !text) return;
            if (state === 'connected') { dot.className = 'dot ok'; text.textContent = 'Connected'; }
            else if (state === 'connecting') { dot.className = 'dot warn'; text.textContent = 'Reconnecting‚Ä¶'; }
            else { dot.className = 'dot err'; text.textContent = 'Offline'; }
        }

        function showConnectionToast(message, autoHideMs) {
            let toast = document.getElementById('connectionToast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'connectionToast';
                toast.className = 'connection-toast';
                document.body.appendChild(toast);
            }
            toast.textContent = message;
            toast.style.display = 'block';
            if (autoHideMs) {
                setTimeout(() => hideConnectionToast(), autoHideMs);
            }
        }

        function hideConnectionToast() {
            const toast = document.getElementById('connectionToast');
            if (toast) toast.style.display = 'none';
        }
        
        function showCurrentScores() {
            // This function can be expanded later to show current scores
            // For now, just show a simple alert
            if (gameState && gameState.players) {
                const currentPlayer = gameState.players.find(p => p.name === playerName);
                if (currentPlayer) {
                    alert(`Your current score: ${currentPlayer.score || 0}`);
                }
            }
        }
        
        // Answer form submission
        document.getElementById('answerForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const answer = document.getElementById('answerInput').value.trim();
            if (!answer) {
                return;
            }
            
            console.log('üì§ Submitting answer:', answer);
            socket.emit('submitAnswer', { gameCode, answer });
            
            // Show "My answer" display
            document.getElementById('myAnswerText').textContent = answer;
            document.getElementById('myAnswerDisplay').style.display = 'block';
            
            // Disable form
            document.getElementById('answerInput').disabled = true;
            document.getElementById('submitBtn').disabled = true;
            document.getElementById('answerStatus').innerHTML = '‚è≥ Submitting answer...';
            document.getElementById('answerStatus').className = 'answer-status pending';
            
            // Store the answer for later display
            window.lastSubmittedAnswer = answer;
            console.log('üíæ Stored answer in window.lastSubmittedAnswer:', answer);

            // Persist to session (same-session refresh resilience)
            try {
                const qIndex = (gameState && typeof gameState.currentQuestion === 'number') ? gameState.currentQuestion : null;
                if (qIndex !== null && gameCode) {
                    sessionStorage.setItem(`lastAnswer-${gameCode}-${qIndex}`, answer);
                }
            } catch (_) {}

            // If no ack arrives soon, allow retry
            awaitingAnswerAck = true;
            clearTimeout(answerAckTimerId);
            answerAckTimerId = setTimeout(() => {
                if (awaitingAnswerAck) {
                    document.getElementById('answerStatus').innerHTML = '‚ö†Ô∏è Still sending‚Ä¶ network is slow. You can retry.';
                    document.getElementById('answerStatus').className = 'answer-status pending';
                    document.getElementById('answerRetryContainer').style.display = 'block';
                }
            }, 2500);
        });

        // Send-to-host (inline input)
        (function(){
            const btn = document.getElementById('askHostBtn');
            const input = document.getElementById('askHostInput');
            const send = function(){
                const q = (input && typeof input.value === 'string') ? input.value.trim() : '';
                if (!q) return;
                console.log('üí¨ [player] Send-to-host clicked (game.html), text:', q);
                try { window.lastAskedQuestion = q; sessionStorage.setItem('lastAskedQuestion', q); } catch(_){}
                try { socket.once('playerQuestionAck', function(ack){ console.log('üí¨ [player] playerQuestionAck (once, game.html):', ack); }); } catch(_){}
                try {
                    const payload = { question: q };
                    try {
                        let gc = sessionStorage.getItem('gameCode') || null;
                        let pn = sessionStorage.getItem('playerName') || null;
                        if (gc) payload.gameCode = gc; if (pn) payload.playerName = pn;
                    } catch(_){}
                    console.log('üí¨ [player] playerQuestion payload (game.html):', payload);
                    socket.emit('playerQuestion', payload);
                } catch(e){ console.warn('üí¨ [player] Failed to emit playerQuestion', e); }
                const statusEl = document.getElementById('answerStatus');
                if (statusEl) {
                    statusEl.innerHTML = `üí¨ You: ${q} ‚Ä¶`;
                    statusEl.className = 'answer-status info';
                }
                if (input) input.value = '';
            };
            if (btn) btn.addEventListener('click', send);
            if (input) input.addEventListener('keypress', function(e){ if (e.key === 'Enter') send(); });
        })();

        // Show ack logs in game.html too
        socket.on('playerQuestionAck', function(ack) {
            console.log('üí¨ [player] playerQuestionAck (game.html):', ack);
        });

        // Retry submission
        document.getElementById('retrySubmitBtn').addEventListener('click', function() {
            if (!window.lastSubmittedAnswer) return;
            console.log('üîÅ Retrying answer submission');
            document.getElementById('answerStatus').innerHTML = '‚è≥ Resubmitting‚Ä¶';
            document.getElementById('answerRetryContainer').style.display = 'none';
            awaitingAnswerAck = true;
            clearTimeout(answerAckTimerId);
            socket.emit('submitAnswer', { gameCode, answer: window.lastSubmittedAnswer });
            answerAckTimerId = setTimeout(() => {
                if (awaitingAnswerAck) {
                    document.getElementById('answerStatus').innerHTML = '‚ö†Ô∏è Still sending‚Ä¶ will keep trying.';
                    document.getElementById('answerRetryContainer').style.display = 'block';
                }
            }, 2500);
        });

        // If the socket reconnects and user has typed but not submitted, surface retry option
        try {
            if (socket && socket.io) {
                socket.io.on('reconnect', () => {
                    try {
                        const input = document.getElementById('answerInput');
                        const submitted = input?.disabled;
                        if (input && !submitted && (input.value || '').trim().length > 0) {
                            const status = document.getElementById('answerStatus');
                            if (status) status.innerHTML = 'üîå Reconnected. You can retry sending your answer.';
                            const retry = document.getElementById('answerRetryContainer');
                            if (retry) retry.style.display = 'block';
                        }
                    } catch (_) {}
                });
            }
        } catch(_) {}
        
        // Enter key focuses on answer input
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('questionScreen').classList.contains('active')) {
                const answerInput = document.getElementById('answerInput');
                if (document.activeElement !== answerInput && !answerInput.disabled) {
                    answerInput.focus();
                }
            }
        });

        // Periodic check to test if we're receiving events
        setInterval(() => {
            if (gameState && gameState.players) {
                console.log('Player: Current player count:', gameState.players.length);
                console.log('Player: Virtual players:', gameState.players.filter(p => p.isVirtual).length);
                console.log('Player: Live players:', gameState.players.filter(p => !p.isVirtual).length);
            }
        }, 5000); // Check every 5 seconds

        // Dynamic Sheep Carousel System
        async function initializeSheepCarousel() {
            try {
                console.log('üêë Fetching sheep photos...');
                const response = await fetch('/api/sheep-urls');
                console.log('üêë API Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('üêë API Response data:', data);
                
                if (data.urls && data.urls.length > 0) {
                    updateSheepCarousel(data.urls);
                    console.log(`üêë Loaded ${data.urls.length} sheep photos for background carousel`);
                    
                    // Test if first image loads
                    const img = new Image();
                    img.onload = () => console.log('‚úÖ First sheep image loaded successfully:', data.urls[0]);
                    img.onerror = () => console.error('‚ùå Failed to load first sheep image:', data.urls[0]);
                    img.src = data.urls[0];
                } else {
                    console.log('üêë No uploaded sheep photos found, using default background');
                }
            } catch (error) {
                console.error('Failed to load sheep photos:', error);
                // Don't throw the error to prevent it from breaking the game
                // Just log it and continue with default background
            }
        }

        function updateSheepCarousel(sheepUrls) {
            console.log('üêë Updating carousel with', sheepUrls.length, 'sheep photos');
            
            // Remove existing animation if it exists
            const existingStyle = document.getElementById('dynamic-sheep-carousel');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (sheepUrls.length === 0) {
                console.log('üêë No sheep URLs provided');
                return;
            }

            // Calculate timing for smooth transitions
            const totalDuration = Math.max(60, sheepUrls.length * 5); // At least 60s, 5s per photo
            const stepPercentage = 100 / sheepUrls.length;

            // Generate CSS keyframes
            let keyframes = '@keyframes sheepCarousel {\n';
            sheepUrls.forEach((url, index) => {
                const percentage = (index * stepPercentage).toFixed(2);
                keyframes += `    ${percentage}% { background-image: url('${url}'); }\n`;
            });
            // Loop back to first image
            keyframes += `    100% { background-image: url('${sheepUrls[0]}'); }\n`;
            keyframes += '}\n\n';

            // Set initial background and animation
            keyframes += `.playing-container::after {\n`;
            keyframes += `    background-image: url('${sheepUrls[0]}');\n`;
            keyframes += `    animation: sheepCarousel ${totalDuration}s linear infinite;\n`;
            keyframes += `}\n`;

            console.log('üêë Generated CSS for carousel:', keyframes.slice(0, 200) + '...');

            // Inject the CSS
            const style = document.createElement('style');
            style.id = 'dynamic-sheep-carousel';
            style.textContent = keyframes;
            document.head.appendChild(style);
            
            console.log('üêë Carousel CSS injected, total duration:', totalDuration + 's');
        }

        // Initialize carousel when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize carousel with error handling
            initializeSheepCarousel().catch(error => {
                console.error('Carousel initialization failed:', error);
                // Continue with game initialization even if carousel fails
            });
            // Guard against losing unsent answer
            window.addEventListener('beforeunload', (e) => {
                const onQuestion = document.getElementById('questionScreen').classList.contains('active');
                const input = document.getElementById('answerInput');
                const submitted = input.disabled;
                if (onQuestion && !submitted && input.value.trim().length > 0) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
        });

        // Refresh carousel every 5 minutes to pick up new uploads
        setInterval(() => {
            initializeSheepCarousel().catch(error => {
                console.error('Carousel refresh failed:', error);
            });
        }, 5 * 60 * 1000);

        // Toast notification function
        function showToast(message, type = 'info') {
            // Remove existing toasts
            const existingToasts = document.querySelectorAll('.toast-notification');
            existingToasts.forEach(toast => toast.remove());
            
            const toast = document.createElement('div');
            toast.className = `toast-notification toast-${type}`;
            toast.innerHTML = `
                <div class="toast-content">
                    <span class="toast-message">${message}</span>
                    <button class="toast-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;
            
            // Add to body for overlay positioning
            document.body.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Auto-remove after 4 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, 4000);
        }
    </script>
</body>
</html> 